<head>
	<title>GameTemplate説明書</title>
</head>

<body>
<h1>GameTemplate説明書</h1>
DXライブラリを用いたゲーム作成のためのテンプレートです。<br>
ダウンロードはこちらからできます ⇒ <a href = "GameTemplate.zip">ver1.04 ダウンロード</a>

<hr>
<h3>もくじ</h3>
<ul>
<li><a href = "#ver03">ver1.03との変更点</a></li>
<li><a href = "#ver02">ver1.02との変更点</a></li>
<li><a href = "#first">使い方</a></li>
<li><a href = "#abstract">概要</a></li>
<li><a href = "#start">色々といじってみよう</a></li>
<li><a href = "#pic">画像を表示してみよう</a></li>
<li><a href = "#text">文字を設定してみよう</a></li>
<li><a href = "#key">キー入力対応させてみよう</a></li>
<li><a href = "#sound">音楽を再生してみよう</a></li>
<li><a href = "#scene">シーンを追加してみよう</a></li>
<li><a href = "#div">画像の分割読み込み</a></li>
<li><a href = "#handle">画像のハンドル指定読み込み</a></li>
<li><a href = "#divGraphic">画像インスタンスを分割する</a></li>
<li><a href = "#motion">複雑な動きをさせてみよう</a></li>
<li><a href = "#screen">スクリーンモードを変更しよう</a></li>
<li><a href = "#save">セーブ・ロード機能を作ろう</a></li>
<li><a href = "#state">クラスに状態を設定する</a></li>
<li><a href = "#keyconfig">キー割り当ての変更</a></li>
<li><a href = "#multi">並列処理について</a></li>
<li><a href = "#icon">アイコンを設定しよう</a></li>
<li><a href = "#complete">ゲームの完成</a></li>
<li><a href = "#sample">サンプルゲーム</a></li>
</ul>
<hr>

<div id = "ver03"></div>
<h2>ver1.03との変更点</h2>
このテンプレートを初めて扱う場合は、この節は<a href = "#first">飛ばして</a>ください。<br>
ver1.02からver1.03に掛けて主に以下の点が変更されています。<br>
<ul>
<li>Randomクラスの仕様変更</li>
<li>マルチスレッドの標準装備</li>
<li>関数名変更Finalization→Finalize</li>
</ul>
<br><h3>【Randomクラスの仕様変更】</h3>
乱数を担うRandomクラスでメルセンヌツイスタを用いるように変更しました。<br>
以前までの使い方とまったく同じようにして使えるはずですが、<br>
乱数の初期値による挙動に以前までのバージョンと互換性を持っていないと思われます。<br>
乱数の範囲指定や、実数の乱数なども使えるようになりました。<br>

<br><h3>【マルチスレッドの標準装備】</h3>
マルチスレッドを標準で使えるように設定しました。<br>
BaseObjectを継承すると、その機能を利用することができます。<br>
これにより、ロード中の画面で素材を読み込みながら画面を動かすなどができます。<br>
詳しくは<a href = "#multi">並列処理について</a>をご覧ください。<br>

<br><h3>【関数名変更Finalization→Finalize】</h3>
細かい変更ですが、CommonDataにおける終了処理Finalizationの名前を<br>
Finalizeに変更しました。Initializeとの対応のためです。<br>

<br><hr>

<div id = "ver02"></div>
<h2>ver1.02との変更点</h2>
このテンプレートを初めて扱う場合は、この節は<a href = "#first">飛ばして</a>ください。<br>
ver1.01からver1.02に掛けて主に以下の点が変更されています。<br>
身内向けをいいことに、かなり仕様変更しました。ごめんなさい。<br>
<ul>
<li>フォルダの名称変更</li>
<li>BaseObjectクラスの追加</li>
<li>Graphicクラス、Soundクラスの仕様変更</li>
<li>Fontクラスの追加</li>
<li>Colorクラスの追加</li>
<li>Motionクラスの追加</li>
<li>convert関数の仕様変更</li>
<li>Vector2とVector2dとを相互変換できるように</li>
<li>スクリーンモード切替の方針修正</li>
</ul>
<br><h3>【フォルダの名称変更】</h3>
共通フォルダを内部システムフォルダに名称変更し、代わりに<br>
表に散らばっていたファイルを共通フォルダに入れました。<br>
紛らわしいですけれど、ご了承ください。こうしたのは単に、すっきりさせるためです。<br>

<br><h3>【BaseObjectクラスの追加】</h3>
基本的な振る舞いを行うものはすべてこれを継承して作るようにしました。<br>
Update、Drawを持ち、その状態を表すState、画像や音楽を持つものです。<br>
サンプルゲーム作っていたときにシーンはpicが使えるのに<br>
シーン以外のベイ助とぴんくりではGraphicポインタをわざわざ宣言しなければならず<br>
不便に感じたので、このようなものを作ることにしました。
シーン以外のクラスもこれを継承すれば、これらが標準で使えるようになります。<br>
シーンもこれを継承して作られているようにしました。<br>
詳しくは<a href = "#state">クラスに状態を設定する</a>をご覧ください。<br>

<br><h3>【Graphicクラス、Soundクラスの仕様変更】</h3>
分割した画像を各々いじれないこととか、ハンドルポインタの宣言とか色々面倒だったので<br>
Graphicの仕様をかなり変えました。それに伴ってSoundも同じような書きかたに変更しました。<br>
まず小さな変更ですが、座標と拡大率を<b>Vector2d型</b>で持つように変えました。<br>
表示するときは整数ですが、実数を持たせたほうが便利なので、以後実数で持たせます。<br>
<br>
本題です。ver1.02までは、<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["単体画像"] = new Graphic("画像パス")<br>
</b></td></tr></tbody></table><br>
というように画像を登録していましたが、newできないようにして、代わりに<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["単体画像"] = Graphic::Create("画像パス")<br>
</b></td></tr></tbody></table><br>
として静的関数から得られるようにしました。<br>
今まで分割画像と呼んでいたものも同じようにすればOKです。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["分割画像"] = Graphic::CreateDiv("画像パス", Vector2(48, 32), Vector2(4, 4))<br>
</b></td></tr></tbody></table><br>
これで、一つ分(48, 32)の大きさの画像が(4, 4)で分割されて使用できます。<br>
<br>
新たにインスタンスの分割ができるようになりました。<br>
これは、画像を分割してそれぞれにGraphicオブジェクトを割り当てるというものです。<br>
こうすることによって、分割した画像各々の座標などをいじることができるようになります。<br>
分割インスタンスを生成するには、以下のように書けばOKです。<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["単体画像分割インスタンス"] = Graphic::CreateDiv("画像パス", Vector2(48, 32), Vector2(5, 8))<br>
</b></td></tr></tbody></table><br>
Createの所をCreateDivにして、第三引数で分割する数を入れます。<br>
戻り値はvertor<Graphic*>になるのでpicでは扱えず、picDivを使ってください。<br>
こうすると、分割した画像のそれぞれの参照は配列のように扱うことができ、<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["単体画像分割インスタンス"][0]->pos = Vector2d(200, 50);<br>
	picDiv["単体画像分割インスタンス"][1]->pos = Vector2d(200, 150);<br>
	picDiv["単体画像分割インスタンス"][2]->pos = Vector2d(200, 250);<br>
</b></td></tr></tbody></table><br>
のような扱いが可能となります。<br>
また、分割したインスタンスそれぞれを更に分割画像にすることも可能です。<br>
RPGツクール2000のキャラチップみたいなイメージです。<br>
あれは一つの画像にキャラクターが横４人、縦２人で８人分、<br>
一人につき足踏み３パターン、向き４パターンで１２パターンの画像が敷き詰められていますが、<br>
それを読み込む場合は次のように書けばOKです。<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["分割画像分割インスタンス"] = Graphic::CreateDiv("画像パス", Vector2(24, 32), Vector2(4, 2), Vector2(3, 4))<br>
</b></td></tr></tbody></table><br>
第二引数が一つ分の大きさ、第三引数がインスタンスの分割数、第四引数がその中での画像の分割数です。<br>
3つのベクトルの各成分の積がちゃんと画像サイズと等しくなるようにしてください。<br>
<br>
画像のハンドルも標準で持つようにしました。<br>
<br><table border = "2"><tbody><tr><td><b>
	picHandle["ハンドル"] = Graphic::CreateHandle("画像パス");<br>
</b></td></tr></tbody></table><br>
これでハンドルが作成されます。分割画像の場合は引数が変わるだけです。<br>
分割インスタンスの場合は、CreateHandleではなくCreateDivHandleになりますが、ハンドルの型は同じです。<br>
画像を作成する際には、<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["単体画像"] = Graphic::Create(picHandle["単体ハンドル"]);<br>
</b></td></tr></tbody></table>
<br><table border = "2"><tbody><tr><td><b>
	pic["分割画像"] = Graphic::Create(picHandle["分割ハンドル"]);<br>
</b></td></tr></tbody></table>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["単体画像分割インスタンス"] = Graphic::CreateDiv(picHandle["単体ハンドル"]);<br>
</b></td></tr></tbody></table>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["分割画像分割インスタンス"] = Graphic::CreateDiv(picHandle["分割ハンドル"]);<br>
</b></td></tr></tbody></table><br>
とすればOKです。<br>
画像、ハンドルの削除はそれぞれ<b>DeletePic</b>、<b>DeletePicDiv</b>、<b>DeletePicHandle</b>で行えます。<br>
<br>
サウンドは、次のように設定します。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["BGM"] = Sound::CreateBGM("BGMパス");<br>
	sound["SE"] = Sound::CreateSE("効果音パス");<br>
</b></td></tr></tbody></table><br>
Play関数で再生できますが、Stopして再度PlayするとBGMでも初めから再生されるようにしました。<br>
Stopに引数としてtrueを与えると再生位置を保持して停止し、<br>
次のPlayでは止めた所から再開されるようにしました。<br>
サウンドの削除はDeleteSoundでOKです。<br>

<br><h3>【Fontクラスの追加】</h3>
GraphicやSoundと同じように、フォントも作って扱えるようにしました。<br>
これによって、実質TCHAR*型は標準で使う機会なくなりました。<br>
多分、文字は全部string型で扱えるようになったと思います。<br>
詳しくは<a href = "#text">文字を設定してみよう</a>をご覧ください。<br>

<br><h3>【Colorクラスの追加】</h3>
色を３つの数値で扱うの面倒になってきたので、Vector2みたいに使えるColorクラス作りました。<br>
範囲外の整数値（0～255以外）を入れると自動で修正してくれるので、少々便利かもしれません。<br>

<br><h3>【Motionクラスの追加】</h3>
キャラクターを二次曲線的に移動させるとか、振動させるとか、<br>
そういう動きを担うクラスとしてMotionクラスを作りました。<br>
BaseMotionを継承すると、自分で好きな動きをするクラスを作成できます。<br>
詳しくは<a href = "#motion">複雑な動きをさせてみよう</a>をご覧ください。<br>

<br><h3>【convert関数の仕様変更】</h3>
昔のが残っていただけで放置していたconvert関数ですが、<br>
それを廃止し、テンプレート関数にして復活させました。<br>
文字列と数値とを変換するための関数です。主にstringとintです。<br>
<b>common::convert&lt;string, int&gt;("12345")</b> とすると<br>
「12345」が数値に変換されて出力されます。<br>
<b>common::convert&lt;int, string&gt;(12345)</b> とすると<br>
数値としての12345が文字列に変換されて出力されます。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["標準"]->Print("現在のスコアは" + common::convert&lt;int, string&gt;(score) + "です。");
</b></td></tr></tbody></table><br>
とか表示するときに便利でしょう。内部ではstringstreamを使っています。<br>
ちなみに、commonと書くのが面倒であれば実装コードの先頭にでも<br>
<br><table border = "2"><tbody><tr><td><b>
	using namespace common;
</b></td></tr></tbody></table><br>
と書いてください。commonやその他いろいろ名前空間にしました。<br>
これで、convertだけで使えるようになります。<br>

<br><h3>【Vector2とVector2dとを相互変換できるように】</h3>
ToDouble()でVector2dに、ToInt()でVector2に変換できるようにしました。<br>
各成分にstatic_castをするのは面倒なので、こちらをお使い下さい。<br>

<br><h3>【スクリーンモード切替の方針修正】</h3>
スクリーンモードを変更するためにChangeWindowMode()を使用すると、<br>
裏画面描画設定まで解除されてしまうために処理が重たくなっていました。<br>
そのため、本当はその後に画像読み込みだけでなく裏画面描画の再設定もしなければならなかったのでした。<br>
しかし、そもそもDXライブラリのフラグを変更することで画像関係のリセットを禁止することができ、<br>
ver1.03からはそれをmain関数内で標準で行うようにしましたので、<br>
これからはスクリーンモードの変更時に画像の再読み込みを行う必要はありません。<br>

<br><hr>

<div id = "first"></div>
<h2>使い方</h2>
このテンプレートはVisual Studio 2013で動作することを想定しています。<br>
それ以前のバージョンですと動作しないと思われるので、2013以降をインストールしてください。<br>
<br>
まず、<a href = "http://homepage2.nifty.com/natupaji/DxLib/" target = "_blank">DXライブラリ</a>を入手してください。<br>
保存場所は任意でいいですが、テンプレートでは<br>
<u>Cドライブ直下に「DxLib」というフォルダ名で保存されたもの</u>を読み込むようにしています。<br>
ディレクトリパスは<b>「C:\DxLib」</b>ということになります。<br>
他のディレクトリにしたい場合は、テンプレートでプロジェクトを作成した後、<br>
DXライブラリの初期設定の方法に従ってパスを指定しなおしてください。<br>
それを新たにテンプレートとしてエクスポートすれば便利だと思います。<br>
ウィザードを手作りできればよかったのですが、何だかめんどくさいのでこのままでご了承ください。<br>
<br>
次に、このページの上部にある<b>GameTemplate.zip</b>をダウンロードしてください。解凍はいらないです。<br>
Visual Studio 2013をインストールしましたら、<br>
どこかに<b>「Visual Studio 2013」</b>というフォルダが生まれると思います（ドキュメントとか）。<br>
その中にある<b>「Templates\ProjectTemplates」</b>の中にGameTemplate.zipをzipのまま放り込んでください。<br>
これで無事、テンプレートが使えるようになると思います。<br>
<br>
Visual Studio 2013を起動しましたら、「新しいプロジェクト」を選択し、<br>
「テンプレート > Visual C++」を選択すると「GameTemplate」が出てきていると思います。<br>
それを選択して「名前」の欄に好きなプロジェクト名を入れましたら、OKしてください。<br>
これにて、ゲームの骨格が完成いたします。<br>
F5を押しますとビルドして実行されますので、ゲーム画面が表示されるかご確認ください。<br>
コードをそのままぶちこんでいますので、初回ビルドは遅いです。<br>
<br><hr>

<div id = "abstract"></div>
<h2>概要</h2>
プロジェクトを作成しますと、ソリューションエクスプローラーにて<br>
<b>ソースファイル、ヘッダーファイル、リソースファイル</b>という３つのフォルダが現れると思います。<br>
その名の通り、ソースファイルにはソースファイル、ヘッダーファイルにはヘッダーファイルを入れています。<br>
リソースファイルは空っぽです。後述するアイコンを設定するときには使いますが、基本いらないと思います。<br>
<br>
ソースファイル、ヘッダーファイルにはそれぞれ<b>シーン、共通、内部システム</b>というフォルダがあります。<br>
いじる必要があるのは<b>大部分が「シーン」フォルダのみ</b>です。<br>
ゲーム全般に関わる共通データを変更する際には、<b>「共通」フォルダ</b>のものをいじります。<br>
<b>「内部システム」フォルダは基本的にいじる必要がないものとして設計しているつもりです。</b><br>
main関数とか、シーンマネージャーとか、見てもややこしくなるだけなものは全部内部システムフォルダに押し込めました。<br>
どんなものがあるか確認ができる程度で済むようにしています。<br>
<br>
以下に、各ファイルの概要を載せます。それぞれ必要なときにいじるのみですから、流し読みで結構です。<br>
内部システムフォルダ内のものを見るときは、ヘッダファイルを見れば色々わかるようにしています。<br>

<br><h3>【メイン画面】（シーン > MainScene.h／.cpp）</h3>
ゲームのメイン画面です。ここをいじれば、ゲームができます。<br>
サンプルでは起動すると「キャンセルキーで終了します」と表示されますが、<br>
実際にMainScene.cppを開くとその文字がそのまんまプログラム中に書かれているのが見られると思います。<br>
小規模なミニゲームを作成するだけなら、メイン画面をいじるだけで十分作れます。<br>
ただ、規模が大きくなってきてタイトル画面やらメニュー画面やらを作成する必要が出てきましたら、<br>
新たにシーンフォルダに画面を追加し、シーンを切り替えるということをしていく必要があります。<br>

<br><h3>【シーン定義】（共通 > Scenes.h）</h3>
シーンを定義している所です。<br>
新しいシーンクラスを作ったときは、GetSceneObject関数にシーン取得の命令を追加する必要があります。<br>
追加する必要があるといっても、１つのシーンにつき２行追加するだけです。<br>

<br><h3>【固定情報データ】（共通 > InfoData.h）</h3>
ゲーム中に変化することのない情報を格納しています。<br>
ゲームタイトルとか、初期ウィンドウサイズ、初期シーン名称など。<br>
何か固定情報を追加することがあれば、既存の記法を真似て作成してください。<br>

<br><h3>【共通データ】（共通 > CommonData.h／.cpp）</h3>
ゲーム中に変化する共通データをまとめています。<br>
共通データとは、シーンをまたいでも変化しない、すべてのシーンに共通するデータのことです。<br>
これには、セーブするデータとセーブしないデータの２種類があります。<br>
それらのデータの宣言と、Inilialize（初期化）関数、Finalize（終了処理）関数の中身の設定、<br>
また、セーブ・ロードの関数を作成するときなどにいじることになります。<br>
セーブデータの仕組みはゲームで共通ではないので、デフォルトではそれらの機能は空っぽになっています。<br>
ですから、セーブ・ロードを行うゲームでは必然的にいじることになります。<br>

<br><h3>【キー入力】（共通 > KeyInput.h／.cpp）</h3>
キー入力のキー割り当てなどを編集することが可能です。キーの状態取得はGetKey関数にて行います。<br>
デフォルトではRPGツクールで使うキーを登録していますが、ここをいじれば好きなキー割り当てが可能です。<br>
列挙型のKeyTypeにてキーの種類を登録し、KeyInput::Initializeにてそれぞれのキーの判定条件を登録してください。<br>
この判定条件はSetKeyCond関数にていつでも変更できますので、これを利用しますと<br>
ゲーム中にプレイヤーがキー割り当てを変更するという機能を作成することが可能です。<br>
CopyKeyCond関数は既存の別のキー判定条件をコピーするものです。<br>

<br><h3>【モーションクラス】（共通 > Motion.h／.cpp）</h3>
新しいモーションを作成するときに使います。<br>
標準では二次曲線と減衰振動のクラスのみ置いています。<br>

<br><h3>【main関数】（内部システム > main.cpp）</h3>
main関数があります。DirectXの初期化を行って実行します。<br>
ゲームオブジェクトを生成してあとはそれに任せていますので、いじる必要ありません。<br>
デバッグ時には常にメモリリーク検査の命令が実行されます。<br>
メモリリークがありますと、その内容がデバッグ出力に表示されます。<br>

<br><h3>【ゲームクラス】（内部システム > Game.h／.cpp）</h3>
ゲームそのもののクラスです。<br>
初期の頃はこれを直に編集しており、規模が大きくなるとSceneManagerを追加するようにしていましたが<br>
めんどくさくなったので、常に持たせるようにしました。いじるような所ないと思います。<br>

<br><h3>【シーンマネージャー】（内部システム > SceneManager.h／.cpp）</h3>
シーンを取り扱う機構です。シーンの切り替えなどをします。<br>

<br><h3>【シーン基底クラス】（内部システム > BaseScene.h／.cpp）</h3>
シーンはこのクラスを継承して作成します。<br>
protected以上のメンバーは各クラスでも自由に利用できますので、ヘッダファイルを眺めて使えそうなのを探してみてください。<br>
シーンを変更するときはChangeScene関数、ゲームを終了するときはEndGame関数を呼び出します。<br>
SetFadeは、画面の色調を変更するものです。デフォルト値は(255, 255, 255)です。<br>
Graphicなどで描画されるものの色調は、ここで指定した色調に依存することになります。<br>
変数として扱うにはscreenFadeを使えば良いです。Color型です。<br>

<br><h3>【オブジェクト基底クラス】（内部システム > BaseObject.h／.cpp）</h3>
ゲーム中における基本的な振る舞いを行うオブジェクトの基底クラスです。<br>
シーンもこれを継承して作られており、その他のオブジェクトを作るときもこれを継承すると便利です。<br>
画像、音楽、フォントはそれぞれpic、sound、fontという連想配列で保持されており、自由に利用可能です。<br>
それらはオブジェクトのデストラクタで自動ですべてのメモリ開放を行いますので、deleteがいらない利点があります。<br>
また、状態を担う列挙型Stateを定義するための機構が揃っています。<br>

<br><h3>【共通ヘッダ】（内部システム > common.h）</h3>
おおよそすべてのファイルはこれをインクルードしています。<br>
よく使うものたちはすべてインクルードしていますので、これだけ呼び出せば便利そうです。<br>
どこでも使用可能な便利関数などを作るときはここに新たに追加するのも手だと思います。<br>

<br><h3>【画像クラス】（内部システム > Graphic.h／.cpp）</h3>
画像を取り扱うクラスです。<br>
いじるものではありませんが、よく使うことになるでしょう。<br>
ヘッダファイルに使える機能をまとめていますので、参考にしてください。<br>

<br><h3>【音楽クラス】（内部システム > Sound.h／.cpp）</h3>
音楽を取り扱うクラスです。<br>
それぞれBGM、効果音を取り込めるようにしているつもりです。<br>
こちらも画像同様、ヘッダファイルに機能をまとめています。br>

<br><h3>【フォントクラス】（内部システム > Font.h／.cpp）</h3>
フォントを取り扱うクラスです。<br>
フォントを作成してそれで文字を表示する一連の機能を使えるようにします。<br>

<br><h3>【モーション基底クラス】（内部システム > BaseMotion.h）</h3>
モーションクラスの基底です。<br>
取り出せる値がなんでもいいように、テンプレートにしています。<br>

<br><h3>【２次元ベクトル】（内部システム > Vector2.h／.cpp）</h3>
Vector2は整数のベクトル、Vector2dは実数のベクトルです。<br>
２次元の値を用いるときは、これを利用したほうがきれいだと思います。<br>

<br><h3>【色】（内部システム > Color.h／.cpp）</h3>
色のクラスです。赤、緑、青の各輝度を設定できます。<br>

<br><h3>【乱数クラス】（内部システム > Random.h／.cpp）</h3>
乱数のクラスです。それだけです。<br>
DefaultRand関数で乱数の初期化が行えますが、これはゲーム開始時に自動で呼ばれます。<br>
引数なしだと現在のタイマーをもとにランダムに初期化しますが、<br>
引数を与えると任意のシードにて乱数の初期化が行えます。リプレイファイルの作成などに用います。<br>
Rand関数にて乱数を発生させることができます。<br>
DRand関数は実数の乱数を範囲指定して発生させられます。<br>
乱数の機構にはメルセンヌツイスタを用いており、メルセンヌツイスタそのものを取り出すにはGetMt関数を用います。<br>

<br><hr>

<div id = "start"></div>
<h2>色々といじってみよう</h2>
ゲームの初期設定を決めている部分は、共通フォルダ内のInfoData.hです。<br>
開くと、ゲームのタイトルやウィンドウのサイズなどが並べられていることが分かります。<br>
ゲームのタイトルは初めにタイトルバーに表記される文字であり、<br>
途中でタイトルバーの文字を変えることがなければ、ここで決めたゲームタイトルがタイトルバーに表記され続けます。<br>
ウィンドウサイズは、ウィンドウモードの場合は好きなサイズのウィンドウに設定可能です。<br>
Vector2(640, 480)とありますが、これは２次元ベクトル型の値です。<br>
横640、縦480の大きさ、ということでパラメータが２つあるので、<br>
一緒に取り扱えば便利だろうという目的からVector2型を採用しています。<br>
ウィンドウモードフラグは初めtrueになっていますが、これをfalseにするとフルスクリーンになります。<br>
また、初期シーン名称はゲーム開始時のシーンの名前であり、後に変更することになりそうな所です。<br>
<br>
このテンプレートではシーンの遷移でゲームの状態を変えるように作ることを想定しており、<br>
例えばタイトル画面からゲームのメイン画面に遷移し、メニューキーを押せばメニュー画面に遷移、<br>
ゲームが終わればエンディング画面に遷移する、など、様々な画面の遷移として大規模なゲームを表現できます。<br>
初めはMainSceneだけですが、シーンは自由に追加していくことが可能です。<br>
<br>
MainScene.hはメイン画面のヘッダファイル、MainScene.cppはメイン画面のソースファイルです。<br>
クラスで使用されている変数や関数の宣言は全部ヘッダファイルにしておき、<br>
ソースファイルを見なくてもヘッダファイルだけでそのクラスの仕様が分かるように作成するのが分かりやすくて良いと思います。<br>
MainScene.cppを覗くと実装部分が見られます。<br>
コンストラクタにて「テキスト」というフォントを作成し、<br>
そのフォントでDraw関数にて「キャンセルキーで終了します」という文字列を描画しています。<br>
シーンには最低限、シーンの初期設定を行うコンストラクタ、シーン終了時の処理を行うデストラクタ、<br>
毎度呼び出されるUpdate、Drawの4つの関数があります。Updateは状態更新、Drawは描画です。<br>
この中を編集していくことで、ゲームを作成していくことが出来るというわけです。<br>
<br><hr>

<div id = "pic"></div>
<h2>画像を表示してみよう</h2>
今は文字だけしかなくて殺風景なので、画像の表示をしてみましょう。<br>
何か画像を用意してください。bmpだけじゃなく、透過pngなどにも対応しています。<br>
↓用意が面倒な場合は、こちらを保存してください。<br>
<img src = "html_dat\pinkri.png"><br>
保存場所は、vcxprojファイルが置かれている場所です。たくさんcppとかhとか置いてある所です。<br>
そこに画像を放り込んでください。<br>
そこがホームディレクトリになるだけですので、相対パスを用いれば任意のフォルダも参照可能です。<br>
上の画像は<b>「pinkri.png」</b>ですので、適宜画像名を置き換えてください。<br>
<br>
まず、画像を登録する必要がありますので、初期設定を書き加えましょう。<br>
初期設定はMainScene::MainScene（コンストラクタ）で行います。その中に次の一行を加えてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = Graphic::Create("pinkri.png");<br>
</b></td></tr></tbody></table><br>
picは標準で使用可能な画像の連想配列です。picの中身は好きな文字列を指定可能です。<br>
これにて「pinkri.png」の画像が読み込まれ、pic["ぴんくり"]でその画像を参照できるようになります。<br>
<br>
実際に描画してみます。描画はMainScene::Drawで行いますので、<br>
BaseScene::Draw();の直後に次の一行を加えてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->Draw();<br>
</b></td></tr></tbody></table><br>
picはGraphicをポインタで持ってるので、ドットではなくアロー演算子で参照することに注意してください。<br>
Draw関数を呼び出すことにより、画像が描画されます。<br>
２行加えただけですが、これで画像が表示されるはずですので、F5で実行してご確認ください。<br>
画像が指定したパスに存在しなくてもエラーは出ず、画像が出ないだけなので<br>
画像が出なければパスが間違っている可能性があります。<br>
成功しますと、左上を基点として画像が描画されていることが確認できます。<br>
<br>
ちなみにBaseScene::Draw();は基底クラスのDrawを呼び出すもので、Updateにも似たものありますけれど<br>
それらは必ず行頭に置くようにしてください。これによって、画面の色調変更などを実現することが可能になります。<br>
<br>
ど真ん中に表示したいので、初期位置を変更します。<br>
画像の登録の行を次のように変更してみてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = Graphic::Create("pinkri.png", Vector2d(320, 240), true);<br>
</b></td></tr></tbody></table><br>
第二引数は画像の初期位置です。第三引数は中心座標を有効にするという意味です。<br>
これがfalseだと（デフォルトではfalseです）左上座標が採用されますが、<br>
それだと不便な場合はここをtrueにしてください。ちゃんとど真ん中に表示されますね。<br>
<br>
ただ、(320, 240)という座標は画面サイズが(640, 480)だから真ん中になるのであって<br>
常に真ん中を指すわけじゃないから不便だよ、というご意見もあるでしょうから<br>
common::GetWindowCenter() でウィンドウの中心座標をVector2d型で返してくれるようにしています。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = Graphic::Create("pinkri.png", common::GetWindowCenter(), true);<br>
</b></td></tr></tbody></table><br>
確かに、この方が分かりやすいかもしれませんね。<br>
<br>
Vector2dは実数の２次元ベクトル型であり、x座標とy座標をまとめて扱うものです。<br>
整数を用いる場合はVector2にしてください。ただし、画像の座標は実数でなければなりません。<br>
<br>
試しにこの画像の登録の直後に<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->fade = 0;<br>
	pic["ぴんくり"]->zoom = 0;<br>
</b></td></tr></tbody></table><br>
を加え、MainScene::Updateのどこかに<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->angle += 0.1;<br>
	pic["ぴんくり"]->zoom++;<br>
	pic["ぴんくり"]->fade++;<br>
</b></td></tr></tbody></table><br>
を入れてみてください。<br>
Updateは状態の更新を行うように設計している関数です。<br>
画像が透明な状態から徐々に、回転しながら大きくなりつつ表示されていく様子が見られると思います。<br>
要領はこれにて良いかと思います。<br>
コンストラクタにてシーン開始時の初期設定を行い、Updateで更新、Drawで描画します。<br>
その呼び出し間隔はリフレッシュレートに依存し、60Hzであれば1秒間に60回行われます。<br>
UpdateしてDraw、というのを1秒間に60回繰り返すということです。<br>
UpdateとDrawを分ける必要ないんじゃないかと思われるかもしれませんが、<br>
分けたほうが分かりやすいだろうという目的で分けているだけなので、<br>
いらない場合はどちらか一方にのみ書き連ねていっても構いません。<br>
<br>
ちなみに、MainScene::~MainSceneはデストラクタです。シーン終了時に呼び出されます。<br>
メモリ確保したものの後始末に利用されると良いですが、<br>
標準で提供しているpicというのは自動で消去されるようにしていますので、後始末は不要です。<br>
シーン中にどうしても手動で削除したい場合は、DeletePic()関数で削除ができます。<br>
すでに登録している画像を差し替えたいときは必ずDeletePicで削除してから新たにCreateしてください。<br>
DeletePicしないで同名の画像にCreateをすると、終了時に初めに登録した画像が残ってしまい、<br>
メモリリークとなってしまうので、ご注意ください。<br>

<br><hr>

<div id = "text"></div>
<h2>文字を設定してみよう</h2>
今度は、文字を設定してみましょう。<br>
コンストラクタにもとからあるこの一行は「テキスト」という名前のフォントを作成していることを意味しています。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"] = Font::Create("メイリオ", Vector2d(10, 10), 24);<br>
</b></td></tr></tbody></table><br>
fontはpic同様、標準で使える連想配列です。<br>
第一引数は使用するフォントの種類名、第二引数は表示位置、第三引数は文字の大きさです。<br>
さらに第四引数で文字の太さ、第五引数でエッジの有無、第六引数でアンチエイリアスの設定ができます。<br>
それらを指定しない場合、デフォルトでエッジなしのアンチエイリアスありが指定されます。<br>
引数の数値を変えて実行、確認してみてください。文字サイズ24の所を100とかにすると、どでかくなります。<br>
<br>
文字にはエッジをつけることも可能です。フォントを作成する部分を以下のように変更してみてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"] = Font::Create("メイリオ", Vector2d(10, 10), 32, 2, true);<br>
	font["テキスト"]->SetColor(Color::Yellow());<br>
	font["テキスト"]->SetEdgeColor(Color::Red());<br>
</b></td></tr></tbody></table><br>
文字の大きさを32、太さを2にして、第五引数にtrueを入れました。<br>
第五引数をtrueにすると、エッジが有効になります。<br>
SetColorで文字の色を変え、SetEdgeColorでエッジの色を変えられます。<br>
デフォルトでは文字が白、エッジが黒になっています。<br>
引数にはColor型の変数値を入れ、赤とか黄色とかは上記のようにして取得できます。<br>
それ以外の場合は例えば、Color::Red()などの所をColor(128, 64, 192)などにしてください。<br>
数値はそれぞれ赤、緑、青の輝度です。<br>
実行してみると、赤いエッジのついた黄色い文字が表示されることが確認できます。<br>
<br>
Draw関数では、作成したフォントを表示しています。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->Print("キャンセルキーで終了します");<br>
</b></td></tr></tbody></table><br>
fontはポインタで持ってるので、ドットではなくアロー演算子で参照することに注意してください。<br>
Print関数の引数に表示したい文字を入れると表示できます。<br>
引数はstring型ですので、string型の変数を用意すれば、引数に変数を用いることももちろん可能です。<br>
<br>
では、今度は文字を動かしてみましょう。<br>
Update関数内のどこかにこの行を追加してみてください。<br>
実際どこでもいいですが、出来るだけBaseScene::Update();より前には何も入れないでください。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->pos.y++;<br>
</b></td></tr></tbody></table><br>
posはフォントの表示座標です。そのy座標が1ずつ上がっていくということになります。<br>
画面はy座標が上がると数学の座標平面と違って下に下がっていくので、<br>
これによって文字が下に下がっていくことになります。<br>
<br>
さらに、表示する文字を変えて現在のテキストのy座標を表示できるようにしてみます。<br>
MainScene.hのメンバーに、表示するテキストの内容を保持する変数を加えてみましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	string text;	// 表示するテキスト<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>
publicの前にstring text;を一行追加しました。これでメイン画面はstring型のtextを保持できるようになります。<br>
MainScene.cppに戻り、Updateに次の二行を追加しましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	int value = font["テキスト"]->pos.ToInt().y;<br>
	text = "今のy座標は" + common::convert&lt;int, string&gt;(value) + "です。";<br>
</b></td></tr></tbody></table><br>
font["テキスト"]->pos.ToInt()とすると、posをVector2d型（実数）からVector2型（整数）に変換できます。<br>
保持しているのは実数ですが、整数を表示したいので整数にしました。そのy座標をvalueに入れます。<br>
このvalueは計算用に使うだけなのでMainSceneのメンバーにしないでUpdateだけで宣言していいです。<br>
変数増えるとややこしくなりますからね＾＾；<br>
次に、textに表示するテキストを入れます。<br>
common::convert&lt;int, string&gt;(value)とすると、valueを整数から文字列に変換できます。<br>
convertは、int型をstring型に変換する文字列変換関数です。逆に&lt;string, int&gt;とすれば文字列を数値に変換できます。<br>
そして、Draw関数でこのtextを表示するように設定します。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->Print(text);<br>
</b></td></tr></tbody></table><br>
これで実行すれば、文字が下に下がりながら、更新されるy座標の値を文字列として表示する様子が見られるでしょう。<br>
ちなみに、これぐらいであれば全部一行でまとめて、<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->Print("今のy座標は" + common::convert&lt;int, string&gt;(font["テキスト"]->pos.ToInt().y) + "です。");<br>
</b></td></tr></tbody></table><br>
としても良いと思いますが、あんまりにも長くなる場合は見づらくなるので<br>
一旦変数におくとか、見やすくしちゃっていいと思います。<br>

<br><hr>

<div id = "key"></div>
<h2>キー入力対応させてみよう</h2>
キー入力は簡単に実現できます。<br>
プロジェクト作成時にUpdate内に<br>
<br><table border = "2"><tbody><tr><td><b>
	if (KeyInput::GetKey(Cancel, PushedNow)){<br>
	&nbsp	EndGame();<br>
	}<br>
</b></td></tr></tbody></table><br>
というのがありますが、これはキャンセルキーを押すとゲームを終了するという処理です。<br>
見てそのまんまだと思うのですが、いかがでしょうか。<br>
<b>KeyInput::GetKey(キーの種類, 取得する状態)</b><br>
とすると、そのキーがその状態にあるかどうかを調べてtrueかfalseか返してくれます。<br>
初めから提供しているキーはKeyInput.hにあるように、以下の通りです。<br>
<br><table border = "2"><tbody><tr><td><b>
	Down,	// ↓<br>
	Left,	// ←<br>
	Right,	// →<br>
	Up,	// ↑<br>
	OK,	// 決定キー<br>
	Cancel,	// キャンセルキー<br>
	Shift,	// シフトキー<br>
	Ctrl,	// コントロールキー<br>
</b></td></tr></tbody></table><br>
KeyTypeの列挙型として保持しています。ジョイスティックパッドにも実は対応しています。<br>
KeyInput::GetKey関数の第一引数にどれかキーの種類を入れて、<br>
第二引数には取得する状態を入れます。<br>
取得する状態はKeyStateの列挙型として以下のように保持しています。<br>
<br><table border = "2"><tbody><tr><td><b>
	PushedNow,	// 押した瞬間<br>
	HasBePushed,	// 押している状態<br>
	ReleaseNow,	// 離した瞬間<br>
	NeverPushed,	// 離している状態<br>
</b></td></tr></tbody></table><br>
キャンセルを押したら終了、という機能はキャンセルキーを押した瞬間を得られればいいので<br>
先ほどのようにPushedNowを第二引数とすればよいですが、<br>
キャラクターの移動など、押しっぱなしでも反応させたい場合はHasBePushedが有効です。<br>
<br>
では実際に、画像を動かしてみましょう。<br>
まず、コンストラクタでは画像の取り込みのみ行うようにします。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = Graphic::Create("pinkri.png", common::GetWindowCenter(), true);
</b></td></tr></tbody></table><br>
Drawでは以下の一行。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->Draw();
</b></td></tr></tbody></table><br>
これで画像がど真ん中に表示される、ということでしたが、<br>
今度はUpdateに、キー入力に応じて画像が移動する処理を追加しましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	if (KeyInput::GetKey(Left, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.x -= 3;<br>
	}<br>
	if (KeyInput::GetKey(Right, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.x += 3;<br>
	}<br>
	if (KeyInput::GetKey(Up, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.y -= 3;<br>
	}<br>
	if (KeyInput::GetKey(Down, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.y += 3;<br>
	}<br>
</b></td></tr></tbody></table><br>
何をしているかはお分かりでしょう。<br>
キーを押すと、座標を足し引きしているのです。<br>
3を足し引きするので、リフレッシュレートが60Hzなら、1／60秒で3ドット移動します。<br>

<br><hr>

<div id = "sound"></div>
<h2>音楽を再生してみよう</h2>
BGMも画像と似たように扱うことができます。<br>
以下はBGM.mp3というファイルを読み込んで再生するサンプルです。<br>
コンストラクタに下のように書いてみましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["BGM"] = Sound::CreateBGM("BGM.mp3");<br>
	sound["BGM"]->Play();<br>
</b></td></tr></tbody></table><br>
picがsoundに、GraphicがBGMになったぐらいです。<br>
読み込んだ直後にPlay()（再生）を実行しています。これで読み込んだBGMが再生されます。<br>
<b>Play()はUpdateやDrawに直に置くのはやめてください。</b><br>
画像はパラパラ漫画のように連続して描画することで動きを表現するものですが、<br>
音楽は再生を一度行えば鳴り続けるもので、<br>
Play()を連続で実行してしまうと連続で再生開始としてしまってえらいことになります。<br>
<br>
効果音の場合は以下のようになります。SE.wavを読み込んで再生する例です。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["効果音"] = Sound::CreateSE("SE.wav");<br>
	sound["効果音"]->Play();<br>
</b></td></tr></tbody></table><br>
BGMがSEに変わっただけです。<br>
BGMとSEの違いは再生位置が終端までいってループするか否か、だけです。<br>
効果音は再生したいタイミングでPlay()を実行してくださればOKです。<br>
Stop()で停止してから再度Play()をすると、どちらも再生位置は初めからに戻ります。<br>
引数で再生位置を設定することも可能です。<br>
ここで、Stop(true)とすると再生位置を保持したまま停止できます。<br>
Play()は引数を省略すると保持した再生位置から再開するので、<br>
Stop(true)をしてからPlay()をすれば、停止した再生位置から再開できます。<br>
<br>
BGMはループ再生するように設定されますが、ループしたときに途中からループさせるには第二引数に値を入れます。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["BGM"] = Sound::CreateBGM("BGM.mp3", 5000);<br>
</b></td></tr></tbody></table><br>
↑BGM.mp3の再生位置が終端までいったら、再生位置5秒の位置からループするという設定です。<br>
第二引数にはループする位置をミリ秒単位で指定します。5000ミリ秒＝5秒ということです。<br>
<br>
再生を停止させるにはStop()を用います。<br>
シーンが切り替わるとpicとsoundはすべて消去されるのでBGMなども自動で停止してしまいますが、<br>
共通データ（CommonData::UnSaveData）にBGMを保持しておいてそれを再生するようにすれば<br>
シーンをまたいでもBGMを再生し続けられるというテクニックもあります。<br>
ただし、BGMの初期化をCommonData::Initializeで行う場合は、<br>
メモリリークを防ぐためにゲーム終了時の処理（CommonData::Finalize）にてメモリ開放してください。<br>

<br><hr>

<div id = "scene"></div>
<h2>シーンを追加してみよう</h2>
シーンとは画面のようなものです。タイトル画面でも追加してみましょう。<br>
<b>「TitleScene」</b>という名前で新たなクラスを作成します。<br>
ソリューションエクスプローラーのどこかてきとうな所で右クリックすると「追加 > クラス」というのが選択できるので<br>
それでC++クラスを選択したらウィザードが開きますから、<br>
クラス名に「TitleScene」を、基底クラスに「BaseScene」を入力してください。<br>
シーンの基底クラスはすべて「BaseScene」です。<br>
すると、「TitleScene.h」と「TitleScene.cpp」が作成されますから、<br>
分かりやすいようにそれぞれ「シーン」フォルダに入れておいてください。<br>
<br>
後はMainSceneを真似て同じような形にすればOKです。<br>
TitleScene.hのTitleSceneクラスのpublic部分に次の２行を追加してください。<br>
<br><table border = "2"><tbody><tr><td><b>
	void Update() override;<br>
	void Draw() override;<br>
</b></td></tr></tbody></table><br>
これにより、BaseSceneのUpdateとDrawをオーバーライドします。<br>
overrideはオーバーライドするということの強調ですが、なくても構いません。<br>
次に、TitleScene.cppのどこかに次の行を追加してください。<br>
<br><table border = "2"><tbody><tr><td><b>
	void TitleScene::Update(){<br>
	&nbsp	BaseScene::Update();<br>
	}<br>
	<br>
	void TitleScene::Draw(){<br>
	&nbsp	BaseScene::Draw();<br>
	}<br>
</b></td></tr></tbody></table><br>
これで、Update関数とDraw関数が定義できました。<br>
BaseScene::Updateは基底クラスのUpdateを、<br>
BaseScene::Drawは基底クラスのDrawをそれぞれ実行するものです。一応常に入れておいてください。<br>
これでTitleSceneの骨格ができました。MainSceneと同じような形になっていることが確認できます。<br>
<br>
そして、TitleSceneをシーンとして登録するためにScene.hを開きます。<br>
一番上にMainSceneのインクルードがあるので、その次の行にこれを入れてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	#include "TitleScene.h"
</b></td></tr></tbody></table><br>
そして、GetSceneObject関数内でMainSceneの記法に従って次の行を追加してください。<br>
<br><table border = "2"><tbody><tr><td><b>
	if (name == "Title")	ret = new TitleScene();
</b></td></tr></tbody></table><br>
これにて、「Title」という名前でTitleSceneのインスタンスを生成できるようになりました。<br>
実際にシーンを切り替えるときはChangeScene("Title")とすればタイトル画面に遷移します。<br>
<br>
それではタイトル画面を表示しましょう。<br>
何でもいいですが、例えば↓この画像をタイトル画面とします。<br>
<img src = "html_dat\title.jpg"><br>
<b>「title.jpg」</b>という名前の、(640, 480)のサイズの画像です。<br>
ついでにこんなのも作りました。<br>
<img src = "html_dat\enter.png"><br>
この画像は<b>「enter.png」</b>です。「Enter押してね」って書いてます。<br>
これの透明度を上げたり下げたりして、それっぽく見せることにします。<br>
「title.jpg」と「enter.png」を読み込んで、Drawにて描画、<br>
「Enter押してね」の方はUpdateにて透明度を上げたり下げたりします。<br>
決定キーを押せば、Main画面に遷移する、ということをしましょう。<br>
<br>
↓こんな感じです。<br>
<br><table border = "2"><tbody><tr><td><b>
	#include "TitleScene.h"<br>
	<br>
	TitleScene::TitleScene(){<br>
	&nbsp	pic["タイトル"] = Graphic::Create("title.jpg");<br>
	&nbsp	pic["押してね"] = Graphic::Create("enter.png", Vector2d(common::GetWindowCenter().x, 400), true);<br>
	}<br>
	<br>
	TitleScene::~TitleScene(){<br>
	}<br>
	<br>
	void TitleScene::Update(){<br>
	&nbsp	BaseScene::Update();<br>
	&nbsp	pic["押してね"]->fade = 128 - 128.0 * cos(0.1 * GetSceneTime());<br>
	&nbsp	if (KeyInput::GetKey(OK, PushedNow)){<br>
	&nbsp	&nbsp	ChangeScene("Main");<br>
	&nbsp	}<br>
	}<br>
	<br>
	void TitleScene::Draw(){<br>
	&nbsp	BaseScene::Draw();<br>
	&nbsp	pic["タイトル"]->Draw();<br>
	&nbsp	pic["押してね"]->Draw();<br>
	}<br>
</b></td></tr></tbody></table><br>
最後に、初期シーンを「Main」から「Title」に変えたいので、<br>
InfoData.hを開きましてDefaultScene()の中身を「Main」から「Title」に変えます。<br>
これにより、初期シーンがタイトル画面になり、決定キーを押せばメイン画面に遷移します。<br>
実際にビルドして実行してみてください。ゲームっぽくなってきました。<br>

<br><hr>

<div id = "div"></div>
<h2>画像の分割読み込み</h2>
画像はGraphic::Createとすれば読み込みが可能ですが、このような画像の場合は単体ずつ読み込むのは非効率です。<br>
<img src = "html_dat\baysuke.png">&copy;Gx2s<br>
画像は<b>「baysuke.png」</b>です。こちらの画像の場合は分割読み込みが有効です。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ベイ助"] = Graphic::Create("baysuke.png", Vector2(32, 48), Vector2(4, 4), common::GetWindowCenter(), true);<br>
</b></td></tr></tbody></table><br>
分割読み込み時には、オーバーロードしたCreate関数を用います。<br>
第二引数に分割時の一つ分の画像サイズを、第三引数に分割する数（横と縦）をそれぞれ入れれば、<br>
これは分割読み込みと認識されて、分割読み込みされた画像の情報が格納されます。<br>
この場合は「baysuke.png」を分割したときの一つ分の大きさは(32, 48)、これを横４つ、縦４つにそれぞれ分割したいので<br>
以上のような構文で入力をします。それ以降の引数は単体読み込みと同じです。<br>
これをMainSceneのコンストラクタに入れて登録しておきましょう。<br>
次に、描画する際には分割されて画像が１６枚になっているので、どれを描画するかを指定する必要があります。<br>
例えば15番を描画したいときは、<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ベイ助"]->Draw(15);<br>
</b></td></tr></tbody></table><br>
となります。Drawの引数に描画する画像の番号を入れます。<br>
<br>
動いてるっぽく見せたいので、試しにDraw内に次のように書いてみてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	int id = (GetSceneTime() / 15) % 16;<br>
	pic["ベイ助"]->Draw(id);<br>
</b></td></tr></tbody></table><br>
GetSceneTimeで、シーンが始まってからの時間（フレーム単位）を取得できます。<br>
それを15で割って16で割った余りを描画する番号idとして決め、描画させてみます。<br>
こうすると、0番、1番、…、15番、と順に表示され、0番に戻る、というのがループされます。<br>
ただそれだけの例ですが、動いてる画像が表示されるのでよりゲームらしくなってきてないでしょうか。<br>
<br>
キャラクターを４方向に歩かせるサンプルです。<br>
<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	int step;	// 足踏みの時間<br>
&nbsp	int id;	// 描画する画像の番号<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene(){<br>
&nbsp	pic["ベイ助"] = Graphic::Create("baysuke.png", Vector2(32, 48), Vector2(4, 4), common::GetWindowCenter(), true);<br>
&nbsp	step = 0;<br>
&nbsp	id = 0;<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (KeyInput::GetKey(Left, HasBePushed)){<br>
&nbsp	&nbsp	pic["ベイ助"]->pos.x -= 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 4;<br>
&nbsp	}<br>
&nbsp	else if (KeyInput::GetKey(Right, HasBePushed)){<br>
&nbsp	&nbsp	pic["ベイ助"]->pos.x += 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 8;<br>
&nbsp	}<br>
&nbsp	else if (KeyInput::GetKey(Up, HasBePushed)){<br>
&nbsp	&nbsp	pic["ベイ助"]->pos.y -= 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 12;<br>
&nbsp	}<br>
&nbsp	else if (KeyInput::GetKey(Down, HasBePushed)){<br>
&nbsp	&nbsp	pic["ベイ助"]->pos.y += 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 0;<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	step = 0;<br>
&nbsp	&nbsp	id = id / 4 * 4;	// 4で割ると小数点以下切捨てされることを利用して番号を戻している<br>
&nbsp	}<br>
&nbsp	id += ((step + 7) / 8) % 4;	// 足踏み時間に応じて番号を加算<br>
<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	pic["ベイ助"]->Draw(id);<br>
}<br>
</b></td></tr></tbody></table><br>
アニメーションなどを作成する場合は、このように一つの画像にまとめて分割した方が便利でしょう。<br>

<br><hr>

<div id = "handle"></div>
<h2>画像のハンドル指定読み込み</h2>
単体読み込み、分割読み込みはいずれも一つのオブジェクトが必ず画像を持っているような形でしたが、<br>
シューティングゲームなど、同じ画像を大量に扱う際にはこれはメモリがもったいなさすぎます。<br>
同じ画像を複数のGraphicオブジェクトが兼用できるようにしたいものです。<br>
<br>
画像は読み込み時にハンドルという番号が与えられ、内部ではそれを用いて画像を描画しています。<br>
ですから、このハンドルを兼用できれば複数のオブジェクトが同一の画像を扱うことができるようになります。<br>
<br>
<img src = "html_dat\bullet.png"><br>
<br>
↑<b>「bullet.png」</b>です。例ではこれを使用することにします。<br>
画像のハンドルを取得するには、以下のように書きます。<br>
<br><table border = "2"><tbody><tr><td><b>
	picHandle["弾のハンドル"] = Graphic::CreateHandle("bullet.png");<br>
</b></td></tr></tbody></table><br>
Graphic::CreateHandleにより、画像のハンドルを取得できます。<br>
ハンドルはGraphicHandle型で保持しており、これはハンドルの配列が格納されているものです。<br>
ハンドルを用いてGraphicオブジェクトを生成するには、以下のように書きます。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["弾"] = Graphic::Create(picHandle["弾のハンドル"]);<br>
</b></td></tr></tbody></table><br>
パスの部分をハンドルに置き換えればいいだけです。<br>
後はハンドルを使いまわしてGraphicオブジェクトを大量生成することが可能です。<br>
<br>
ハンドルで取得した画像は<b>Graphicオブジェクトを削除しても消えません。</b><br>
実際に画像のデータ削除するためにはハンドルを削除する必要があります。<br>
<b>DeletePicHandle(ハンドル名)</b>とすればハンドルで指定した画像を削除し、ついでにハンドルポインタも消えます。<br>
特別に消す必要がない場合は、消さなくてもpicやsoundと同様シーン終了時に勝手に消えてくれます。<br>
<br>
ただし、何らかの用途でpicで保持しないGraphic型変数などを使用する場合は、<br>
当然ながらそれらは勝手には消えませんから、十分注意してください。<br>
勝手に消えるのは、標準で使えるpic、sound、picDiv、picHandle、fontのみです。<br>
<br>
弾画像を大量に発生させてみましょう。<br>
以下は1000個の弾を中心から一斉に分散させるサンプルです。<br>
きれいと思うか、気持ち悪いと思うかは、人を選びそうですが＾＾；<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	Graphic* bullet[1000];	// 弾の画像<br>
&nbsp	double bullet_speed[1000];	// 弾の速度<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
using namespace common;<br>
<br>
MainScene::MainScene(){<br>
&nbsp	picHandle["弾ハンドル"] = Graphic::CreateHandle("bullet.png");	// 弾画像のハンドル取得<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	bullet[i] = Graphic::Create(picHandle["弾ハンドル"], GetWindowCenter(), true);	// ハンドルを割り当て<br>
&nbsp	&nbsp	bullet[i]->angle = 180.0 * Random::Rand(360) / 3.141592;	// 投射角度を360°からランダムに指定<br>
&nbsp	&nbsp	bullet[i]->fade = 0;	// 弾は初め透明とする<br>
&nbsp	&nbsp	bullet_speed[i] = 0.02 * Random::Rand(100);	// 弾のスピードをランダムに指定<br>
&nbsp	}<br>
}<br>
<br>
MainScene::~MainScene(){<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	Graphic::Delete(bullet[i]);	// 必ずメモリ開放すること<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	// 弾の位置を角度とスピードから、実数値で計算<br>
&nbsp	&nbsp	bullet[i]->pos.x += bullet_speed[i] * cos(bullet[i]->angle);<br>
&nbsp	&nbsp	bullet[i]->pos.y -= bullet_speed[i] * sin(bullet[i]->angle);<br>
<br>
&nbsp	&nbsp	// 不透明度を上げていく<br>
&nbsp	&nbsp	bullet[i]->fade++;<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	bullet[i]->Draw();	// すべて描画<br>
&nbsp	}<br>
}<br>
</b></td></tr></tbody></table><br>
画像を配列として扱いたいので、Graphicポインタの配列変数を作りました。<br>
これは自分で宣言したものなので、デストラクタでメモリ開放を行うことを忘れないようにしてください。<br>
ちなみに、commonは名前空間ですので、上記のように「using namespace common;」とすればcommonを省略できるようになります。<br>
<br>
分割読み込み画像のハンドル取得は以下のようにします。<br>
<br><table border = "2"><tbody><tr><td><b>
	picHandle["ハンドル"] = Graphic::CreateHandle("baysuke.png", Vector2(32, 48), Vector2(4, 4));<br>
</b></td></tr></tbody></table><br>
第二引数に一つ分の画像サイズ、第三引数に分割数を入れれば、分割読み込み画像のハンドルを取得できます。<br>
これを用いてGraphicのインスタンス化をするときは、一つ分の大きさや分割数は必要ありません。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ベイ助"] = Graphic::Create(picHandle["ハンドル"]);
</b></td></tr></tbody></table><br>
単体読み込みのハンドル指定とまったく同じように扱うことができます。<br>

<br><hr>

<div id = "divGraphic"></div>
<h2>画像インスタンスを分割する</h2>
一つの画像を分割表示することは出来るようになりましたが、<br>
これは表示するときに画像の一部分のみ描画する機能でしかなく、<br>
画像を分割して各々に座標を持たせて移動させるなどということは出来ません。<br>
これは、画像そのものを分割しているだけでGraphicオブジェクトはただ一つなためです。<br>
そうではなく、画像を分割したものを各々Graphicオブジェクトとして独立させたいときもあります。<br>
例えばこのような画像を読み込ませたいときです。<br>
<br>
<img src = "html_dat\menu.png"><br>
<br>
これは<b>「menu.png」</b>という一枚の画像です。<br>
透明度や座標を各々の項目で持たせたいので、それぞれ単独のGraphicとして保持したいです。<br>
画像ファイルそのものを分けちゃえばいいと言われればそうなのですが、<br>
画像を分割して各々がGraphicを持つという機能を標準で持たせています。<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["メニュー"] = Graphic::CreateDiv("menu.png", Vector2(280, 74), Vector2(1, 3));
</b></td></tr></tbody></table><br>
CreateDivでインスタンスを分割した配列を作成します。それをpicDivに入れています。<br>
picDivも標準で使用可能な変数であり、vector<Graphic*>を持てます。<br>
さっきのメニュー画像は一つ分が(280, 74)なので、第二引数には(280, 74)を入れます。<br>
第三引数は分割する個数です。縦に3個並んでいるので(1, 3)ですね。<br>
<br>
分割インスタンスで作成された画像はDeletePicDiv()で削除してください。<br>
また、ハンドルで指定する場合は分割インスタンスの場合、<br>
<br><table border = "2"><tbody><tr><td><b>
	picHandle["ハンドル"] = Graphic::CreateDivHandle("menu.png", Vector2(280, 74), Vector2(1, 3));<br>
</b></td></tr></tbody></table><br>
と書くことになります。CreateDivHandleでハンドルを作成しますが、ハンドルはpicHandleでOKです。<br>
実際にこれを用いて画像を作成するときは、<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["メニュー"] = Graphic::CreateDiv(picHandle["ハンドル"]);<br>
</b></td></tr></tbody></table><br>
これでOKです。ハンドルはインスタンスが単体だろうと分割だろうと同じです。<br>
ですので、ハンドル削除はDeletePicHandle()でOKです。<br>
<br>
さっきのメニュー画像を使ったサンプルです。<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	string text;	// 表示するテキスト<br>
&nbsp	int cursor;	// カーソル番号<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
using namespace common;<br>
<br>
MainScene::MainScene(){<br>
&nbsp	font["フォント"] = Font::Create("メイリオ", Vector2d(10, 10), 24, 2);<br>
&nbsp	picDiv["メニュー"] = Graphic::CreateDiv("menu.png", Vector2(280, 74), Vector2(1, 3), GetWindowCenter(), true);<br>
&nbsp	for (int i = 0; i < 3; i++){<br>
&nbsp	&nbsp	picDiv["メニュー"][i]->pos.y += 100.0 * (i - 1);	// 1番中心に縦100ずつ離す<br>
&nbsp	}<br>
&nbsp	text = "メニュー選択";<br>
&nbsp	cursor = 0;	// カーソル番号（0, 1, 2）<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (KeyInput::GetKey(Up, PushedNow)){<br>
&nbsp	&nbsp	cursor--;<br>
&nbsp	&nbsp	if (cursor < 0){<br>
&nbsp	&nbsp	&nbsp	cursor = 2;<br>
&nbsp	&nbsp	}<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(Down, PushedNow)){<br>
&nbsp	&nbsp	cursor++;<br>
&nbsp	&nbsp	if (cursor >= 3){<br>
&nbsp	&nbsp	&nbsp	cursor = 0;<br>
&nbsp	&nbsp	}<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(OK, PushedNow)){<br>
&nbsp	&nbsp	switch (cursor){<br>
&nbsp	&nbsp	case 0:<br>
&nbsp	&nbsp	&nbsp	text = "はじめからを選択しました。";<br>
&nbsp	&nbsp	&nbsp	break;<br>
&nbsp	&nbsp	case 1:<br>
&nbsp	&nbsp	&nbsp	text = "つづきからを選択しました。";<br>
&nbsp	&nbsp	&nbsp	break;<br>
&nbsp	&nbsp	case 2:<br>
&nbsp	&nbsp	&nbsp	EndGame();<br>
&nbsp	&nbsp	&nbsp	break;<br>
&nbsp	&nbsp	}<br>
&nbsp	}<br>
&nbsp	for (int i = 0; i < 3; i++){<br>
&nbsp	&nbsp	if (i == cursor){<br>
&nbsp	&nbsp	&nbsp	picDiv["メニュー"][i]->fade = 256;<br>
&nbsp	&nbsp	&nbsp	picDiv["メニュー"][i]->SetZoom(100);<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	else{<br>
&nbsp	&nbsp	&nbsp	picDiv["メニュー"][i]->fade = 128;<br>
&nbsp	&nbsp	&nbsp	picDiv["メニュー"][i]->SetZoom(80);<br>
&nbsp	&nbsp	}<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	for (int i = 0; i < 3; i++){<br>
&nbsp	&nbsp	picDiv["メニュー"][i]->Draw();<br>
&nbsp	}<br>
&nbsp	font["フォント"]->Print(text);<br>
}<br>
</b></td></tr></tbody></table><br>
カーソルは3以上だと0に、0未満だと2にするようにしていますが、実は<br>
1足して3以上なら0にする、というのは「cursor = (cursor + 1) % 3;」、<br>
1引いて0未満なら2にする、というのは「cursor = (cursor + 2) % 3;」、でそれぞれOKです。<br>
引くほうがなぜ2足して3で割った余りを計算するようにしているかというと、<br>
cursorが0だと1引いたら負になり、負の数を割った余りを計算することになってしまうためです。<br>
この計算がうまく行われないので、負にならないようにさらに3を足すということをしています。<br>
0から2だと分かりづらいかもしれませんが、例えば0から99の場合は、<br>
1足す方は「cursor = (cursor + 1) % 100;」、1引く方は「cursor = (cursor + 99) % 100;」、となります。<br>
<br>
分割したそれぞれのインスタンスは、自分たちの持つ画像領域を更に分割画像として保持することが可能です。<br>
その場合、このように記述します。<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["分割分割画像"] = Graphic::CreateDiv("menu.png", Vector2(70, 37), Vector2(1, 3), Vector2(4, 2));<br>
</b></td></tr></tbody></table><br>
menu.pngを(1, 3)で分割し、それぞれがGraphicインスタンスを持っている状態で、<br>
さらにその中を(4, 2)で各々分割して保持することになります。<br>
各々が分割した画像を描画するときは、画像の分割時と同様Draw関数の引数で描画番号を指定します。<br>
つまり、各々のGraphicが<a href = "#div">画像の分割読み込み</a>の節の機能を持てるということになります。<br>
こんなの何に使うんだと思われそうですが、こういうのに使います。<br>
<br>
<img src = "html_dat\chara.png"><br>
<br>
アニメーション等を含んだ画像を一括で読み込むときなどで良いかもしれません。<br>
<br><hr>

<div id = "motion"></div>
<h2>複雑な動きをさせてみよう</h2>
共通フォルダにあるMotion.hでは動きを担うモーションクラス群が宣言されています。<br>
デフォルトでは二次曲線と減衰振動を扱うことができますが、自作も可能です。<br>
<br>
試しに利用してみましょう。画像が(0, 0)からスタートして(320, 480)を頂点に、(640, 0)まで移動します。<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	Motion::Curve curve;	// 二次曲線<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene() : curve(Vector2d(320, 480)){<br>
&nbsp	pic["ぴんくり"] = Graphic::Create("pinkri.png", Vector2d(0, 0), true);<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (!curve.IsFinished()){<br>
&nbsp	&nbsp	curve.Update();<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos = Vector2d(GetSceneTime(), curve.GetValue());<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	pic["ぴんくり"]->Draw();<br>
}<br>
</b></td></tr></tbody></table><br>

Motion::Curve型の変数を持たせ、初期値を与えるためにコンストラクタで<br>
<b>curve(Vector2d(320, 480))</b>としています。頂点は(320, 480)とする、という意味です。<br>
しかしコンストラクタの上部でこのように定義するのは見づらいですし、途中で欲しくなったとき困るので<br>
そういうときはポインタにして、必要なときにnewしてください。その際、必ずdeleteもするようにしてください。<br>
curveに初期値を与えたら、Update内でcurve.Update();をします。<br>
これで値が更新され、curve.GetValue()からそのときの値を取り出すことができます。<br>
終了したかどうかは、curve.IsFinished()がtrueかどうかで分かります。<br>
二次曲線の場合はPassedVertex()で頂点を通過したかどうかも判別できます。<br>
<br>
同様にして減衰振動も扱うことができます。減衰振動はMotion::Wave型です。<br>
パラメータは(setValue, a, b, c, d)の5つです。<br>
<b>ae^(-bt)sin(ct+d)</b>の減衰振動をしながらsetValueに収束するということになります。<br>
つまり、aは振幅、bは減衰スピード、cは波立ちの速さ、dは波立ちの初期位置となります。<br>
b＝0とすれば減衰しなくなりますので、普通の振動として扱うことができます。<br>
c＝0とすると波立ちしなくなりますが、あんまり意味はないと思います。<br>
減衰振動はサンプルゲームで使っていますので、参考にしてみてください。<br>
<br>
では、モーションを自作してみましょう。<br>
ある点にある時間を掛けて行く、という動きを作ってみることとします。<br>
Motion.hのMotionの名前空間の中、Waveクラスの直後にでもこれを追加してみてください。<br>
<br><table border = "2"><tbody><tr><td><b>
// 指定した座標へ移動<br>
class Move : public BaseMotion&lt;Vector2d&gt;{<br>
&nbsp	Vector2d startPos;	// 最初の座標<br>
&nbsp	Vector2d endPos;	// 最後に到達する座標<br>
&nbsp	int finishTime;	// 終了する時間<br>
public:<br>
&nbsp	Move(Vector2d startPos, Vector2d endPos, int finishTime);<br>
&nbsp	void Update() override;<br>
};<br>
</b></td></tr></tbody></table><br>
Moveクラスを作ります。BaseMotionを継承し、保持する値の型を決めます。<br>
ここでは座標を返したいので、Vector2d型とします。<br>
初期位置startPos、終了位置endPosを決め、到達するのにfinishTime掛かるとします。<br>
コンストラクタではそれぞれの値を入れられるように、Updateは基底クラスのをオーバーライドします。<br>
<br>
Motion.cppにて実装をします。以下を追加してみてください。どこでもいいです。<br>
<br><table border = "2"><tbody><tr><td><b>
Move::Move(Vector2d startPos, Vector2d endPos, int finishTime){<br>
&nbsp	this->startPos = startPos;<br>
&nbsp	this->endPos = endPos;<br>
&nbsp	this->finishTime = finishTime;<br>
&nbsp	if (finishTime == 0){<br>
&nbsp	&nbsp	Finished();<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	value = startPos;<br>
&nbsp	}<br>
}<br>
<br>
void Move::Update(){<br>
&nbsp	BaseMotion&lt;Vector2d&gt;::Update();<br>
&nbsp	if (IsFinished()){<br>
&nbsp	&nbsp	value = endPos;<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	value += (endPos - startPos) / finishTime;<br>
&nbsp	&nbsp	if (time >= finishTime){<br>
&nbsp	&nbsp	&nbsp	Finished();<br>
&nbsp	&nbsp	}<br>
&nbsp	}<br>
}<br>
</b></td></tr></tbody></table><br>
コンストラクタで引数を受け取り、自分のメンバーに代入した後、<br>
もしfinishTimeが0ならすでに終わっているので、Finished()をします。<br>
Finished()をすると終了したということになります。<br>
通常はfinishTimeは0ではないでしょうから、そうなるときvalueにstartPosを初期値として入れます。<br>
Update内ではもし終わっていたらvalueにendPosを代入するようにし、<br>
そうでなければendPosからstartPosまでの差を時間（finishTime）で割った分だけvalueに加算します。<br>
もし時間がfinishTime以上になったらFinished()として、終了します。<br>
これでモーションが完成しました。<br>
<br>
実際にこのモーションを利用してみましょう。<br>
先ほどのMainScene.hでのcurveの宣言の行を<b>Motion::Move move;</b>に変更し、<br>
MainScene.cppの方は次のように変更してみましょう。<br>

<br><table border = "2"><tbody><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene() : move(Vector2d(100, 350), Vector2d(500, 150), 120){<br>
&nbsp	pic["ぴんくり"] = Graphic::Create("pinkri.png", Vector2d(100, 350), true);<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	move.Update();<br>
&nbsp	pic["ぴんくり"]->pos = move.GetValue();<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	pic["ぴんくり"]->Draw();<br>
}<br>
</b></td></tr></tbody></table><br>
画像が(100, 350)からスタートして、2秒（120フレーム）掛けて(500, 150)へ移動する様子が見られるはずです。<br>
<br><hr>

<div id = "screen"></div>
<h2>スクリーンモードを変更しよう</h2>
InfoDataをいじれば初期設定をフルスクリーンにすることができますが、ゲーム中でも<br>
<b>ChangeWindowMode(true)</b>でウィンドウモードに、<br>
<b>ChangeWindowMode(false)</b>でフルスクリーンに変更できます。<br>
ver1.02ではこのとき、すべてのグラフィックデータが消去されてしまう状態になっていましたが<br>
そうならないようにDXライブラリの設定をしなおしましたので、特に留意することはありません。<br>
スクリーンモードを変更したいときに自由に使ってください。<br>
BGMの再生と同様、Updateの中に直置きするなど、<b>常にループする所には置かないように注意してください。</b><br>

<br><hr>

<div id = "save"></div>
<h2>セーブ・ロード機能を作ろう</h2>
ゲームのセーブデータは、それぞれのゲームによって異なります。<br>
ここでは最も単純に、一つの変数をテキストに保存するというのを実現してみましょう。<br>
Enterキーを押すと増える変数で、その変数値はゲームを終了してもテキストに保持されるとします。<br>
<br>
まず、CommonData.hを開き、空っぽのSaveData構造体の中にこれを追加します。<br>
<br><table border = "2"><tbody><tr><td><b>
	int enterNum;	// Enterを押した回数
</b></td></tr></tbody></table><br>
この共通データは、CommonData::saveData.enterNumとしてどこででも参照が可能です。<br>
では今度はCommonData.cppを開きましょう。<br>
ゲームが始まったときにCommonData::Initialize関数が実行されます。<br>
これは、共通データの初期値を決めるものです。セーブデータがない状態の値と考えて良いです。<br>
CommonData::Initializeの中に以下を追加しましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	saveData.enterNum = 0;
</b></td></tr></tbody></table><br>
セーブデータに用いられているenterNumは、初めは0とします。<br>
<br>
それでは、セーブとロードの関数を作成しましょう。今は空っぽのままになっています。<br>
テキストに変数を読み書きするだけなので、C++の標準的な書き方でOKです。<br>
例えば以下のようになるでしょう。<br>
<br><table border = "2"><tbody><tr><td><b>
bool CommonData::Save(string path){<br>
&nbsp	ofstream ofs(path);<br>
&nbsp	bool ret = !ofs.fail();<br>
&nbsp	if (ret){<br>
&nbsp	&nbsp	ofs << saveData.enterNum;<br>
&nbsp	}<br>
&nbsp	return ret;<br>
}<br>
<br>
bool CommonData::Load(string path){<br>
&nbsp	ifstream ifs(path);<br>
&nbsp	bool ret = !ifs.fail();<br>
&nbsp	if (ret){<br>
&nbsp	&nbsp	string buf;<br>
&nbsp	&nbsp	getline(ifs, buf);<br>
&nbsp	&nbsp	saveData.enterNum = common::convert&lt;string, int&gt;(buf);<br>
&nbsp	}<br>
&nbsp	return ret;<br>
}<br>
</b></td></tr></tbody></table><br>
これで、enterNumを読み書きする機構が完成しました。<br>
実際にゲームに組み込んでみましょう。<br>
<br>
MainSceneで実験をしてみたいと思います。<br>
比較用に、セーブしないただのenterNumをMainSceneに持たせてみましょう。<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	int enterNum;	// 今回Enterを押した回数<br>
&nbsp	int enterTime;	// 次にEnterを押せるようになるまでの時間<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
using namespace common;<br>
<br>
MainScene::MainScene(){<br>
&nbsp	font["フォント"] = Font::Create("メイリオ", Vector2d(10, 10), 32);<br>
<br>
&nbsp	enterNum = 0;<br>
&nbsp	enterTime = 0;<br>
&nbsp	pic["ぴんくり"] = Graphic::Create("pinkri.png", common::GetWindowCenter(), true);<br>
&nbsp	CommonData::Load("セーブデータ.txt");	// ロード<br>
}<br>
<br>
MainScene::~MainScene(){<br>
&nbsp	CommonData::Save("セーブデータ.txt");	// セーブ<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (KeyInput::GetKey(OK, PushedNow) && enterTime == 0){<br>
&nbsp	&nbsp	enterNum++;	// 今回のEnter回数（終了時に消える）<br>
&nbsp	&nbsp	CommonData::saveData.enterNum++;	// Enter回数の総数（セーブされる）<br>
&nbsp	&nbsp	enterTime = 30;<br>
&nbsp	}<br>
<br>
&nbsp	if (KeyInput::GetKey(Cancel, PushedNow)){<br>
&nbsp	&nbsp	EndGame();<br>
&nbsp	}<br>
<br>
&nbsp	if (enterTime > 0){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.y = 100.0 / (15 * 15) * (enterTime - 15) * (enterTime - 15) + GetWindowCenter().y - 100.0;<br>
&nbsp	&nbsp	enterTime--;<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	pic["ぴんくり"]->Draw();<br>
<br>
&nbsp	font["フォント"]->Print("今回Enterを押した回数　　：" + convert&lt;int, string&gt;(enterNum));<br>
&nbsp	font["フォント"]->Print("今までにEnterを押した総数：" + convert&lt;int, string&gt;(CommonData::saveData.enterNum), Vector2d(0, 30));<br>
}<br>
</b></td></tr></tbody></table><br>
Enterを押すと画像がジャンプするようにしました。<br>
コンストラクタにてLoadを行い、「セーブデータ.txt」を読み込みます。<br>
もし読み込みに失敗したとき（初回起動でファイルが存在しない場合など）は何事も無くスルーされます。<br>
テキストを無事読み込めたら、数値を取り込んでゲームに反映させます。<br>
また、デストラクタでSaveを行うようにしました。<br>
つまり、ゲームを終了させたときにEnterを押した総数が保存されるようになります。<br>
<br>
セーブデータの作り方は様々ですので、ゲームの様態に合わせて作成してみてください。<br>
ハッシュなどを用いてセーブデータの改竄を防ぐなどといったテクニックもあります。<br>

<br><hr>

<div id = "state"></div>
<h2>クラスに状態を設定する</h2>
シーンの規模が大きくなってくると、シーンの状態を扱いたくなってきます。<br>
例えばメニュー画面を作っているとき、メニューのトップにいるのか、装備画面にいるのか、セーブ画面にいるのか、など<br>
一つの画面であっても状態を複数扱えて切り替えられるようにできたら便利です。<br>
実はシーンはBaseObjectクラスを継承しており、これは状態を持たせるための機能があるほか、pic、soundなどを標準で使えるようになっています。<br>
ですから、シーンではないクラスでもBaseObjectを継承すれば同等の機能が利用できるようになるのです。<br>
基本的に、ゲーム中のオブジェクトはおおかたこれを継承すれば作りやすいようになっています。<br>
継承したら、Update()とDraw()の一番上の行に、シーンのときと似たようにそれぞれ<br>
<b>BaseObject::Update();</b>、<b>BaseObject::Draw();</b>を忘れずに入れてください。<br>
<br>
Stateは列挙型として定義します。ChangeState()によって定義したStateに変更できます。<br>
デフォルトではこれは一番上の状態になるように設定されています。<br>
現在どのStateにあるかはGetState()によって取得できるので、これによって条件分岐などすると良いでしょう。<br>
Stateを変更すると、その状態になってからの時間stateTimeが初期化されます。<br>
これはGetStateTime()で参照できるもので、1フレームにつき1上がります。<br>
一方、そのシーンになってからの経過時間はGetSceneTime()で取得できます。<br>
<br>
なんだか色々ありますが、状態設定を施した以下のサンプルをご覧ください。<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	enum State{<br>
&nbsp	&nbsp	start,	// 初期演出<br>
&nbsp	&nbsp	select,	// 選択肢<br>
&nbsp	&nbsp	print,	// 文字の表示<br>
&nbsp	&nbsp	end,	// 終了演出<br>
&nbsp	};<br>
&nbsp	int cursor;	// カーソル<br>
&nbsp	Motion::Curve motion;	// モーション<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
using namespace common;<br>
<br>
MainScene::MainScene() : motion(Vector2d(240, InfoData::WindowSize().x)){<br>
&nbsp	font["テキスト"] = Font::Create("メイリオ", Vector2d(10 + InfoData::WindowSize().x, 10), 24);<br>
&nbsp	font["状態表示"] = Font::Create("メイリオ", Vector2d(InfoData::WindowSize().x - 150, InfoData::WindowSize().y - 24), 16);<br>
&nbsp	cursor = 0;<br>
&nbsp	ChangeState(State::start);<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	switch (GetState()){<br>
&nbsp	case State::start:<br>
&nbsp	&nbsp	motion.Update();<br>
&nbsp	&nbsp	if (motion.PassedVertex()){<br>
&nbsp	&nbsp	&nbsp	font["テキスト"]->pos = Vector2d(10, 10);<br>
&nbsp	&nbsp	&nbsp	ChangeState(State::select);<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	else{<br>
&nbsp	&nbsp	&nbsp	font["テキスト"]->pos.x = 10 + InfoData::WindowSize().x - motion.GetValue(); <br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	break;<br>
&nbsp	case State::select:<br>
&nbsp	&nbsp	if (KeyInput::GetKey(Up, PushedNow)){<br>
&nbsp	&nbsp	&nbsp	cursor = (cursor + 3) % 4;<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	if (KeyInput::GetKey(Down, PushedNow)){<br>
&nbsp	&nbsp	&nbsp	cursor = (cursor + 1) % 4;<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	if (KeyInput::GetKey(OK, PushedNow)){<br>
&nbsp	&nbsp	&nbsp	if (cursor != 3){<br>
&nbsp	&nbsp	&nbsp	&nbsp	ChangeState(State::print);<br>
&nbsp	&nbsp	&nbsp	} else{<br>
&nbsp	&nbsp	&nbsp	&nbsp	motion.Initialize();<br>
&nbsp	&nbsp	&nbsp	&nbsp	ChangeState(State::end);<br>
&nbsp	&nbsp	&nbsp	}<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	break;<br>
&nbsp	case State::print:<br>
&nbsp	&nbsp	if (KeyInput::GetKey(OK, PushedNow)){<br>
&nbsp	&nbsp	&nbsp	ChangeState(State::select);<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	break;<br>
&nbsp	case State::end:<br>
&nbsp	&nbsp	motion.Update();<br>
&nbsp	&nbsp	if (motion.PassedVertex()){<br>
&nbsp	&nbsp	&nbsp	EndGame();<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	else{<br>
&nbsp	&nbsp	&nbsp	font["テキスト"]->pos.y = 10 + 0.8 * motion.GetValue();<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	break;<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	font["状態表示"]->Print("scenetime : " + convert&lt;int, string&gt;(GetSceneTime()));<br>
&nbsp	font["状態表示"]->Print("statetime : " + convert&lt;int, string&gt;(GetStateTime()), Vector2d(0, -24));<br>
&nbsp	switch (GetState()){<br>
&nbsp	case State::start:<br>
&nbsp	&nbsp	font["状態表示"]->Print("state : start", Vector2d(0, -48));<br>
&nbsp	&nbsp	font["テキスト"]->Print("！初期演出です！");<br>
&nbsp	&nbsp	break;<br>
&nbsp	case State::select:<br>
&nbsp	&nbsp	font["状態表示"]->Print("state : select", Vector2d(0, -48));<br>
&nbsp	&nbsp	font["テキスト"]->Print("選択肢を何か選んでください");<br>
&nbsp	&nbsp	font["テキスト"]->Print("⇒", Vector2d(20, 50 + 30 * cursor));<br>
&nbsp	&nbsp	font["テキスト"]->Print("今日の天気は何でしょうか", Vector2d(50, 50));<br>
&nbsp	&nbsp	font["テキスト"]->Print("好きな食べ物は何でしょうか", Vector2d(50, 80));<br>
&nbsp	&nbsp	font["テキスト"]->Print("そもそも、これは何なの", Vector2d(50, 110));<br>
&nbsp	&nbsp	font["テキスト"]->Print("もーやめます", Vector2d(50, 140));<br>
&nbsp	&nbsp	break;<br>
&nbsp	case State::print:<br>
&nbsp	&nbsp	font["状態表示"]->Print("state : print", Vector2d(0, -48));<br>
&nbsp	&nbsp	switch (cursor){<br>
&nbsp	&nbsp	case 0:<br>
&nbsp	&nbsp	&nbsp	font["テキスト"]->Print("わかんないですよ！");<br>
&nbsp	&nbsp	&nbsp	break;<br>
&nbsp	&nbsp	case 1:<br>
&nbsp	&nbsp	&nbsp	font["テキスト"]->Print("お寿司が好きです＾＾");<br>
&nbsp	&nbsp	&nbsp	break;<br>
&nbsp	&nbsp	case 2:<br>
&nbsp	&nbsp	&nbsp	font["テキスト"]->Print("これは黒い画面とたわむれるためのものです");<br>
&nbsp	&nbsp	&nbsp	break;<br>
&nbsp	&nbsp	}<br>
&nbsp	&nbsp	break;<br>
&nbsp	case State::end:<br>
&nbsp	&nbsp	font["状態表示"]->Print("state : end", Vector2d(0, -48));<br>
&nbsp	&nbsp	font["テキスト"]->Print("しょんにゃああああああ；ｗ；");<br>
&nbsp	&nbsp	break;<br>
&nbsp	}<br>
}<br>
</b></td></tr></tbody></table><br>
start、select、print、endの4つの状態を持っており、その時々で状態が変わるようにしています。<br>
一つの画面で色々なことをできるようにするときは便利かもしれません。<br>

<br><hr>

<div id = "keyconfig"></div>
<h2>キー割り当ての変更</h2>
ゲーム中にキー割り当てを変更することもできます。<br>
キー入力の判定条件はラムダ式で保持されており、<br>
判定条件を変えるときは対応するキーの判定条件に新たなラムダ式をセットしてやればOKです。<br>
<br>
以下は、Enterを押すと上下左右のキーの判定条件が反転するサンプルです。<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	bool reverseFlg;	// 反転フラグ<br>
&nbsp	void SetKeys();	// キーの判定条件のセット<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
using namespace common;<br>
<br>
MainScene::MainScene(){<br>
&nbsp	font["テキスト"] = Font::Create("メイリオ", Vector2d(10, 10), 32);<br>
&nbsp	pic["ぴんくり"] = Graphic::Create("pinkri.png", GetWindowCenter(), true);<br>
&nbsp	reverseFlg = false;<br>
&nbsp	SetKeys();<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (KeyInput::GetKey(Left, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.x -= 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(Right, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.x += 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(Up, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.y -= 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(Down, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.y += 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(OK, PushedNow)){<br>
&nbsp	&nbsp	reverseFlg ^= 1;	// 反転<br>
&nbsp	&nbsp	SetKeys();<br>
&nbsp	}<br>
&nbsp}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	pic["ぴんくり"]->Draw();<br>
<br>
&nbsp	if (!reverseFlg){<br>
&nbsp	&nbsp	font["テキスト"]->Print("通常");<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	font["テキスト"]->Print("反転");<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::SetKeys(){<br>
&nbsp	if (!reverseFlg){<br>
&nbsp	&nbsp	// 通常<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Left, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_LEFT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Right, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_RIGHT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Up, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_UP) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Down, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_DOWN) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	// 反転<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Left, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_RIGHT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Right, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_LEFT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Up, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_DOWN) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Down, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_UP) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	}<br>
}<br>
</b></td></tr></tbody></table><br>

もう一つ、CopyKeyCond関数というのもあります。これは別のキーの判定条件をコピーする関数です。<br>
例えば、CopyKeyCond(Cancel, OK)とするとキャンセルキーに決定キーの判定条件が割り当てられます。<br>
キー配置をプレイヤーが自由に設定できるようなオプションの作成などに利用できるでしょう。<br>

<br><hr>

<div id = "multi"></div>
<h2>並列処理について</h2>
ロード中の画面で、素材を読み込みながら「NowLoading」の文字を動かすなどしてみたいときがあります。<br>
そういうときは、メインで文字を動かしながら素材読み込み処理を並列で実行し、<br>
素材の読み込みが完了したら画面遷移する、ということをすれば良いですね。<br>
ver1.04から並列処理に標準で対応できるようになりました。<br>
<br>
BaseObjectを継承したクラス（シーンも継承しています）は<br>
標準で並列処理のためのスレッド配列を保持しており、<br>
並列処理を使いたくなったらスレッドを登録すれば即座に処理が始まります。<br>
スレッドの追加をするにはAddThread関数を用います。<br>
引数に処理したい関数やラムダ式を入れることで、その処理を並列に行うようになります。<br>
GetThreadTotalNum関数により登録されているスレッドの総数を、<br>
GetFinishedThreadNum関数によりそのうち完了したスレッドの数を与えます。<br>
すべてのスレッドが終わっている状態は上の二つの関数値が一致するときですが、<br>
これはAllThreadFinished関数の戻り値がtrueであることと同値になります。<br>
この関数はその名の通り、すべてのスレッドが終了していたらtrueを返す関数です。<br>
スレッドが0個のときは常にtrueが返ります。<br>
ですから、登録したスレッドが終了したかどうかの確認はAllThreadFinishedにて行い、<br>
これがtrueになるまでの間ロード中の表示をし続ければ良いのです。<br>
登録したスレッドを全消去するにはClearThread関数を用います。<br>
また、スレッドすべてが完全に終了するまで全体処理を停止させる命令としてWaitForThread関数もありますが<br>
念のため用意した程度で、使わなくてよいと思います。<br>
<br>
<br><table border = "2"><tbody><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene(){<br>
&nbsp	font["テキスト"] = Font::Create("メイリオ", Vector2d(100, 100), 48, 4, true);<br>
&nbsp	AddThread([&]{	// 素材読み込みをするときは「&」にしないと読み込みが反映されない<br>
&nbsp	&nbsp	Sleep(500);	// ロード中の処理<br>
&nbsp	&nbsp	Sleep(500);	// ロード中の処理<br>
&nbsp	&nbsp	Sleep(500);	// ロード中の処理<br>
&nbsp	&nbsp	Sleep(500);	// ロード中の処理<br>
&nbsp	&nbsp	Sleep(500);	// ロード中の処理<br>
&nbsp	});<br>
&nbsp	loadFlg = false;<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (AllThreadFinished()){<br>
&nbsp	&nbsp	loadFlg = true;<br>
&nbsp	&nbsp	ClearThread();<br>
&nbsp	}<br>
<br>
&nbsp	if (loadFlg){<br>
&nbsp	&nbsp	font["テキスト"]->pos = Vector2d(100, 100);<br>
&nbsp	&nbsp	font["テキスト"]->SetColor(Color::White());<br>
&nbsp	&nbsp	int i = static_cast&lt;int&gt;(128.0 + 127.0 * cos(0.5 * GetSceneTime()));<br>
&nbsp	&nbsp	font["テキスト"]->SetEdgeColor(Color(i, i, 0));<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	font["テキスト"]->pos.x = static_cast&lt;int&gt;(100.0 + 50.0 * sin(0.1 * GetSceneTime()));<br>
&nbsp	&nbsp	int i = static_cast&lt;int&gt;(192.0 + 63.0 * sin(0.3 * GetSceneTime()));<br>
&nbsp	&nbsp	font["テキスト"]->SetColor(Color(i, i, i));<br>
&nbsp	&nbsp	i = static_cast&lt;int&gt;(128.0 + 127.0 * cos(0.2 * GetSceneTime()));<br>
&nbsp	&nbsp	font["テキスト"]->SetEdgeColor(Color(i, i, i));<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	if (loadFlg){<br>
&nbsp	&nbsp	font["テキスト"]->Print("ロード完了！！");<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	font["テキスト"]->Print("ロード中です...");<br>
&nbsp	}<br>
}<br>
</b></td></tr></tbody></table><br>
<br>
↑ロード中のサンプルです。ヘッダにbool型のloadFlgを追加してください。<br>
AddThread内にて本当は素材を読み込む処理を入れることになります。<br>
その処理が完了するまでの間はAllThreadFinishedがfalseなのでloadFlgがfalseのまま、<br>
完了すればtrueとなって「ロード完了！！」と表示されるように切り替わることになります。<br>
<br>
スレッドはあんまりたくさん追加しない方が良いと思います。<br>
ロード中でもしゲージや「％」など、進行度も表示させたい場合は<br>
スレッドを複数用意して小分けするのでなく、進行度を表す変数みたいなのをあらかじめ用意しておいて<br>
一つの大きなスレッド内で素材を読み込むたびにその進行度を増やしていくような手法にした方が良さそうです。<br>

<br><hr>

<div id = "icon"></div>
<h2>アイコンを設定しよう</h2>
ゲームのアイコンを設定してみましょう。<br>
<br><table border = "2"><tbody><tr><th>icon.ico</th></tr><tr><td>
<img src = "html_dat\icon.ico" width = "64"><br>
</td></tr></tbody></table><br>
何でもいいですが、とりあえずアイコン画像を用意します。ここでは<b>「icon.ico」</b>とします。<br>
このファイルは今までのようにvcxprojがあったディレクトリではなく、その一階層前の、slnファイルのある場所に置いてください。<br>
そして、同じディレクトリに<b>「Resource.rc」</b>という空のファイルを作成してください。<br>
これにてリソースファイルの定義を行います。Resource.rcをテキストエディタで開き、次のように書いてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	101 ICON "icon.ico"<br>
</b></td></tr></tbody></table><br>
この場合は「icon.ico」なのでこう書いていますが、別のファイル名の場合は適宜変えてください。<br>
テンプレートではアイコン101番をウィンドウアイコンとして指定するようにしていますので、<br>
それにアイコンにしたい画像ファイルを関連付けることによってアイコンを設定できます。<br>
<br>
最後に、Visual Studioに戻ってソリューションエクスプローラーの「リソースファイル」に<br>
先ほどの「Resource.rc」のみ入れてください。これでビルドをすると、アイコンが置き換わるはずです。<br>

<br><hr>

<div id = "complete"></div>
<h2>ゲームの完成</h2>
晴れてゲームが完成しましたら、リリースビルドをして完成品にしましょう。<br>
ソリューション構成の「Debug」を「Release」に変更してビルドを行えば、リリースビルド完了です。<br>
素材の相対パスはできあがった実行ファイル（.exe）のあるディレクトリになるので、<br>
そこを相対パスとして素材を入れてください。<br>
<br>
素材はDXアーカイブ機能を用いることにより一つの「dxaファイル」にまとめることが可能です。<br>
便利な機能ですので、ぜひ別途ご参照ください。<br>
ただし、セーブデータなどはもちろんそれにはまとめられないのでご注意ください。<br>
<br>
<br>
このテンプレートは、DXライブラリをオブジェクト指向的に利用するためのものに過ぎず、<br>
また、２Ｄゲームを作成することしか想定されておりません。十分な機能をそろえるにもまだまだ足らないです。<br>
ご本家のDXライブラリには非常に多くの機能がありますので、<br>
より高度なことを行うためにはそちらをご参照になり、どんどん機能を拡張させていってください。<br>

<br><hr>

<div id = "sample"></div>
<h2>サンプルゲーム</h2>
今までご紹介しました機能を利用すれば、おおかたゲーム作れると思います。<br>
サンプルとしてゲームウォッチのヘルメットのリメイク作りましたので、参考にどうぞ。<br>
⇒ <a href = "http://yahoo.jp/box/g8ysdA" target = "_blank">ダウンロードサイトに飛びます</a><br>
<br>
テンプレートをver1.04に更新したので、これも新しいテンプレートの書き方に合わせて改変しました。<br>
ロード中の間に並列処理が行えるようになったので、「NowLoading」の表示が光るようになってます＾＾；<br>
その他、目に見える違いはほぼありませんが、ぴんくりの生産の仕方を変えたために<br>
画面にいるぴんくりの数をカウントして表示する機能のためにしなければならないことがいくつか出てしまうので<br>
ゲーム開始後にぴんくりが出現した総数を代わりに表示するようにしています。<br>
今までどおり画面中のぴんくりの数を表示するようにするには、<br>
MainSceneにぴんくりの数を持たせるようにすればよいでしょう。<br>
<br>
単なるサンプルのはずが、色々詰め込んでしまって疲れたので、注釈あんまりありません。<br>
各クラスを閲覧する場合はヘッダファイルを見ておおよそ概要をつかんでいただき、<br>
必要なとこだけソースファイル見る、という形が良いと思います。<br>
内部システムフォルダの中身はテンプレートの初期状態からまったく変えていませんのでご安心ください。<br>
勢いで作ってしまったためにサンプルになってないんじゃないかというような作りですが、ご了承下さい。<br>

<br><hr>

2014年12月15日記 フェルミウム湾<br>
<br>

</body>
