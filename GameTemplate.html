<head>
	<title>GameTemplate説明書</title>
</head>

<body>
<h1>GameTemplate説明書</h1>
DXライブラリを用いたゲーム作成のためのテンプレートです。<br>
ダウンロードはこちらからできます ⇒ <a href = "GameTemplate.zip">ver1.03 ダウンロード</a>

<hr>
<h3>もくじ</h3>
<ul>
<li><a href = "#ver02">ver1.02との変更点</a></li>
<li><a href = "#first">使い方</a></li>
<li><a href = "#abstract">概要</a></li>
<li><a href = "#start">色々といじってみよう</a></li>
<li><a href = "#pic">画像を表示してみよう</a></li>
<li><a href = "#text">文字を設定してみよう</a></li>
<li><a href = "#key">キー入力対応させてみよう</a></li>
<li><a href = "#sound">音楽を再生してみよう</a></li>
<li><a href = "#scene">シーンを追加してみよう</a></li>
<li><a href = "#div">画像の分割読み込み</a></li>
<li><a href = "#handle">画像のハンドル指定読み込み</a></li>
<li><a href = "#divGraphic">画像インスタンスを分割する</a></li>
<li><a href = "#motion">複雑な動きをさせてみよう</a></li>
<li><a href = "#state">クラスに状態を設定する</a></li>
<li><a href = "#screen">スクリーンモードを変更しよう</a></li>
<li><a href = "#save">セーブ・ロード機能を作ろう</a></li>
<li><a href = "#keyconfig">キー割り当ての変更</a></li>
<li><a href = "#icon">アイコンを設定しよう</a></li>
<li><a href = "#complete">ゲームの完成</a></li>
<li><a href = "#sample">サンプルゲーム</a></li>
</ul>
<hr>

<div id = "ver02"></div>
<h2>ver1.02との変更点</h2>
このテンプレートを初めて扱う場合は、この節は飛ばしてください。<br>
ver1.02から主に以下の点が変更されています。<br>
身内向けをいいことに、かなり仕様変更しました。ごめんなさい。<br>
<ul>
<li>フォルダの名称変更</li>
<li>Behaviorクラスの追加</li>
<li>Graphicクラス、Soundクラスの仕様変更</li>
<li>Fontクラスの追加</li>
<li>Motionクラスの追加</li>
<li>convert関数の仕様変更</li>
<li>Vector2とVector2dとを相互変換できるように</li>
</ul>
<br><h3>【フォルダの名称変更】</h3>
共通フォルダを内部システムフォルダに名称変更し、代わりに<br>
表に散らばっていたファイルを共通フォルダに入れました。<br>
紛らわしいですけれど、ご了承ください。こうしたのは単に、すっきりさせるためです。<br>

<br><h3>【Behaviorクラスの追加】</h3>
基本的な振る舞いを行うものはすべてこれを継承して作るようにしました。<br>
Update、Drawを持ち、その状態を表すState、画像や音楽を持つものです。<br>
サンプルゲーム作っていたときにシーンはpicが使えるのに<br>
シーン以外のベイ助とぴんくりではGraphicポインタをわざわざ宣言しなければならず<br>
不便に感じたので、このようなものを作ることにしました。
シーン以外のクラスもこれを継承すれば、これらが標準で使えるようになります。<br>
シーンもこれを継承して作られているようにしました。<br>
詳しくは<a href = "#state">クラスに状態を設定する</a>をご覧ください。<br>

<br><h3>【Graphicクラス、Soundクラスの仕様変更】</h3>
分割した画像を各々いじれないこととか、ハンドルポインタの宣言とか色々面倒だったので<br>
Graphicの仕様をかなり変えました。それに伴ってSoundも同じような書きかたに変更しました。<br>
まず小さな変更ですが、座標と拡大率を<b>Vector2d型</b>で持つように変えました。<br>
表示するときは整数ですが、実数を持たせたほうが便利なので、以後実数で持たせます。<br>
<br>
本題です。ver1.02までは、<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["単体画像"] = new Graphic("画像パス")<br>
</b></td></tr></tbody></table><br>
というように画像を登録していましたが、newできないようにして、代わりに<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["単体画像"] = Graphic::Create("画像パス")<br>
</b></td></tr></tbody></table><br>
として静的関数から得られるようにしました。<br>
今まで分割画像と呼んでいたものも同じようにすればOKです。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["分割画像"] = Graphic::CreateDiv("画像パス", Vector2(48, 32), Vector2(4, 4))<br>
</b></td></tr></tbody></table><br>
これで、一つ分(48, 32)の大きさの画像が(4, 4)で分割されて使用できます。<br>
<br>
新たにインスタンスの分割ができるようになりました。<br>
これは、画像を分割してそれぞれにGraphicオブジェクトを割り当てるというものです。<br>
こうすることによって、分割した画像各々の座標などをいじることができるようになります。<br>
分割インスタンスを生成するには、以下のように書けばOKです。<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["単体画像分割インスタンス"] = Graphic::CreateDiv("画像パス", Vector2(48, 32), Vector2(5, 8))<br>
</b></td></tr></tbody></table><br>
Createの所をCreateDivにして、第三引数で分割する数を入れます。<br>
戻り値はvertor<Graphic*>になるのでpicでは扱えず、picDivを使ってください。<br>
こうすると、分割した画像のそれぞれの参照は配列のように扱うことができ、<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["単体画像分割インスタンス"][0]->pos = Vector2d(200, 50);<br>
	picDiv["単体画像分割インスタンス"][1]->pos = Vector2d(200, 150);<br>
	picDiv["単体画像分割インスタンス"][2]->pos = Vector2d(200, 250);<br>
</b></td></tr></tbody></table><br>
のような扱いが可能となります。<br>
また、分割したインスタンスそれぞれを更に分割画像にすることも可能です。<br>
RPGツクール2000のキャラチップみたいなイメージです。<br>
あれは一つの画像にキャラクターが横４人、縦２人で８人分、<br>
一人につき足踏み３パターン、向き４パターンで１２パターンの画像が敷き詰められていますが、<br>
それを読み込む場合は次のように書けばOKです。<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["分割画像分割インスタンス"] = Graphic::CreateDiv("画像パス", Vector2(24, 32), Vector2(4, 2), Vector2(3, 4))<br>
</b></td></tr></tbody></table><br>
第二引数が一つ分の大きさ、第三引数がインスタンスの分割数、第四引数がその中での画像の分割数です。<br>
3つのベクトルの各成分の積がちゃんと画像サイズと等しくなるようにしてください。<br>
<br>
画像のハンドルも標準で持つようにしました。<br>
<br><table border = "2"><tbody><tr><td><b>
	picHandle["ハンドル"] = Graphic::CreateHandle("画像パス");<br>
</b></td></tr></tbody></table><br>
これでハンドルが作成されます。分割画像の場合は引数が変わるだけです。<br>
分割インスタンスの場合は、CreateHandleではなくCreateDivHandleになりますが、ハンドルの型は同じです。<br>
画像を作成する際には、<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["単体画像"] = Graphic::Create(picHandle["単体ハンドル"]);<br>
</b></td></tr></tbody></table>
<br><table border = "2"><tbody><tr><td><b>
	pic["分割画像"] = Graphic::Create(picHandle["分割ハンドル"]);<br>
</b></td></tr></tbody></table>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["単体画像分割インスタンス"] = Graphic::CreateDiv(picHandle["単体ハンドル"]);<br>
</b></td></tr></tbody></table>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["分割画像分割インスタンス"] = Graphic::CreateDiv(picHandle["分割ハンドル"]);<br>
</b></td></tr></tbody></table><br>
とすればOKです。<br>
画像、ハンドルの削除はそれぞれ<b>DeletePic</b>、<b>DeletePicDiv</b>、<b>DeletePicHandle</b>で行えます。<br>
<br>
サウンドは、次のように設定します。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["BGM"] = Sound::CreateBGM("BGMパス");<br>
	sound["SE"] = Sound::CreateSE("効果音パス");<br>
</b></td></tr></tbody></table><br>
Play関数で再生できますが、Stopして再度PlayするとBGMでも初めから再生されるようにしました。<br>
Stopに引数としてtrueを与えると再生位置を保持して停止し、<br>
次のPlayでは止めた所から再開されるようにしました。<br>
サウンドの削除はDeleteSoundでOKです。<br>

<br><h3>【Fontクラスの追加】</h3>
GraphicやSoundと同じように、フォントも作って扱えるようにしました。<br>
これによって、実質TCHAR*型は標準で使う機会なくなりました。<br>
多分、文字は全部string型で扱えるようになったと思います。<br>
詳しくは<a href = "#text">文字を設定してみよう</a>をご覧ください。<br>

<br><h3>【Motionクラスの追加】</h3>
キャラクターを二次曲線的に移動させるとか、振動させるとか、<br>
そういう動きを担うクラスとしてMotionクラスを作りました。<br>
MotionBaseを継承すると、自分で好きな動きをするクラスを作成できます。<br>
詳しくは<a href = "#motion">複雑な動きをさせてみよう</a>をご覧ください。<br>

<br><h3>【convert関数の仕様変更】</h3>
昔のが残っていただけで放置していたconvert関数ですが、<br>
それを廃止し、テンプレート関数にして復活させました。<br>
文字列と数値とを変換するための関数です。主にstringとintです。<br>
<b>common::convert&lt;string, int&gt;("12345")</b> とすると<br>
「12345」が数値に変換されて出力されます。<br>
<b>common::convert&lt;int, string&gt;(12345)</b> とすると<br>
数値としての12345が文字列に変換されて出力されます。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["標準"]->Print("現在のスコアは" + common::convert&lt;int, string&gt;(score) + "です。");
</b></td></tr></tbody></table><br>
とか表示するときに便利でしょう。内部ではstringstreamを使っています。<br>
ちなみに、commonと書くのが面倒であれば実装コードの先頭にでも<br>
<br><table border = "2"><tbody><tr><td><b>
	using namespace common;
</b></td></tr></tbody></table><br>
と書いてください。commonやその他いろいろ名前空間にしました。<br>
これで、convertだけで使えるようになります。<br>

<br><h3>【Vector2とVector2dとを相互変換できるように】</h3>
ToDouble()でVector2dに、ToInt()でVector2に変換できるようにしました。<br>
各成分にstatic_castをするのは面倒なので、こちらをお使い下さい。<br>

<br><hr>

<div id = "first"></div>
<h2>使い方</h2>
このテンプレートはVisual Studio 2013で動作することを想定しています。<br>
それ以前のバージョンですと動作しないと思われるので、2013以降をインストールしてください。<br>
<br>
まず、<a href = "http://homepage2.nifty.com/natupaji/DxLib/" target = "_blank">DXライブラリ</a>を入手してください。<br>
保存場所は任意でいいですが、テンプレートでは<br>
<u>Cドライブ直下に「DxLib」というフォルダ名で保存されたもの</u>を読み込むようにしています。<br>
ディレクトリパスは<b>「C:\DxLib」</b>ということになります。<br>
他のディレクトリにしたい場合は、テンプレートでプロジェクトを作成した後、<br>
DXライブラリの初期設定の方法に従ってパスを指定しなおしてください。<br>
それを新たにテンプレートとしてエクスポートすれば便利だと思います。<br>
ウィザードを手作りできればよかったのですが、何だかめんどくさいのでこのままでご了承ください。<br>
<br>
次に、このページの上部にある<b>GameTemplate.zip</b>をダウンロードしてください。解凍はいらないです。<br>
Visual Studio 2013をインストールしましたら、<br>
どこかに<b>「Visual Studio 2013」</b>というフォルダが生まれると思います（ドキュメントとか）。<br>
その中にある<b>「Templates\ProjectTemplates」</b>の中にGameTemplate.zipをzipのまま放り込んでください。<br>
これで無事、テンプレートが使えるようになると思います。<br>
<br>
Visual Studio 2013を起動しましたら、「新しいプロジェクト」を選択し、<br>
「テンプレート > Visual C++」を選択すると「GameTemplate」が出てきていると思います。<br>
それを選択して「名前」の欄に好きなプロジェクト名を入れましたら、OKしてください。<br>
これにて、ゲームの骨格が完成いたします。<br>
F5を押しますとビルドして実行されますので、ゲーム画面が表示されるかご確認ください。<br>
コードをそのままぶちこんでいますので、初回ビルドは遅いです。<br>
<br><hr>

<div id = "abstract"></div>
<h2>概要</h2>
プロジェクトを作成しますと、ソリューションエクスプローラーにて<br>
<b>ソースファイル、ヘッダーファイル、リソースファイル</b>という３つのフォルダが現れると思います。<br>
その名の通り、ソースファイルにはソースファイル、ヘッダーファイルにはヘッダーファイルを入れています。<br>
リソースファイルは空っぽです。後述するアイコンを設定するときには使いますが、基本いらないと思います。<br>
<br>
ソースファイル、ヘッダーファイルにはそれぞれ<b>シーン、共通、内部システム</b>というフォルダがあります。<br>
いじる必要があるのは<b>大部分が「シーン」フォルダのみ</b>です。<br>
ゲーム全般に関わる共通データを変更する際には、<b>「共通」フォルダ</b>のものをいじります。<br>
<b>「内部システム」フォルダは基本的にいじる必要がないものとして設計しているつもりです。</b><br>
main関数とか、シーンマネージャーとか、見てもややこしくなるだけなものは全部内部システムフォルダに押し込めました。<br>
どんなものがあるか確認ができる程度で済むようにしています。<br>
<br>
以下に、各ファイルの概要を載せます。それぞれ必要なときにいじるのみですから、流し読みで結構です。<br>
内部システムフォルダ内のものを見るときは、ヘッダファイルを見れば色々わかるようにしています。<br>

<br><h3>【メイン画面】（シーン > MainScene.h／.cpp）</h3>
ゲームのメイン画面です。ここをいじれば、ゲームができます。<br>
サンプルでは起動すると「キャンセルキーで終了します」と表示されますが、<br>
実際にMainScene.cppを開くとその文字がそのまんまプログラム中に書かれているのが見られると思います。<br>
小規模なミニゲームを作成するだけなら、メイン画面をいじるだけで十分作れます。<br>
ただ、規模が大きくなってきてタイトル画面やらメニュー画面やらを作成する必要が出てきましたら、<br>
新たにシーンフォルダに画面を追加し、シーンを切り替えるということをしていく必要があります。<br>

<br><h3>【シーン定義】（共通 > Scenes.h）</h3>
シーンを定義している所です。<br>
新しいシーンクラスを作ったときは、GetSceneObject関数にシーン取得の命令を追加する必要があります。<br>
追加する必要があるといっても、１つのシーンにつき２行追加するだけです。<br>

<br><h3>【固定情報データ】（共通 > InfoData.h）</h3>
ゲーム中に変化することのない情報を格納しています。<br>
ゲームタイトルとか、初期ウィンドウサイズ、初期シーン名称など。<br>
何か固定情報を追加することがあれば、既存の記法を真似て作成してください。<br>

<br><h3>【共通データ】（共通 > CommonData.h／.cpp）</h3>
ゲーム中に変化する共通データをまとめています。<br>
共通データとは、シーンをまたいでも変化しない、すべてのシーンに共通するデータのことです。<br>
これには、セーブするデータとセーブしないデータの２種類があります。<br>
それらのデータの宣言と、Inilialize（初期化）関数、Finalization（終了処理）関数の中身の設定、<br>
また、セーブ・ロードの関数を作成するときなどにいじることになります。<br>
セーブデータの仕組みはゲームで共通ではないので、デフォルトではそれらの機能は空っぽになっています。<br>
ですから、セーブ・ロードを行うゲームでは必然的にいじることになります。<br>

<br><h3>【キー入力】（共通 > KeyInput.h／.cpp）</h3>
キー入力のキー割り当てなどを編集することが可能です。キーの状態取得はGetKey関数にて行います。<br>
デフォルトではRPGツクールで使うキーを登録していますが、ここをいじれば好きなキー割り当てが可能です。<br>
列挙型のKeyTypeにてキーの種類を登録し、KeyInput::Initializeにてそれぞれのキーの判定条件を登録してください。<br>
この判定条件はSetKeyCond関数にていつでも変更できますので、これを利用しますと<br>
ゲーム中にプレイヤーがキー割り当てを変更するという機能を作成することが可能です。<br>
CopyKeyCond関数は既存の別のキー判定条件をコピーするものです。<br>

<br><h3>【モーションクラス】（共通 > Motion.h／.cpp）</h3>
新しいモーションを作成するときに使います。<br>
標準では二次曲線と減衰振動のクラスのみ置いています。<br>

<br><h3>【main関数】（内部システム > main.cpp）</h3>
main関数があります。DirectXの初期化を行って実行します。<br>
ゲームオブジェクトを生成してあとはそれに任せていますので、いじる必要ありません。<br>
デバッグ時には常にメモリリーク検査の命令が実行されます。<br>
メモリリークがありますと、その内容がデバッグ出力に表示されます。<br>

<br><h3>【ゲームクラス】（内部システム > Game.h／.cpp）</h3>
ゲームそのもののクラスです。<br>
初期の頃はこれを直に編集しており、規模が大きくなるとSceneManagerを追加するようにしていましたが<br>
めんどくさくなったので、常に持たせるようにしました。いじるような所ないと思います。<br>

<br><h3>【シーンマネージャー】（内部システム > SceneManager.h／.cpp）</h3>
シーンを取り扱う機構です。シーンの切り替えなどをします。<br>

<br><h3>【シーン基底クラス】（内部システム > BaseScene.h／.cpp）</h3>
シーンはこのクラスを継承して作成します。<br>
protected以上のメンバーは各クラスでも自由に利用できますので、ヘッダファイルを眺めて使えそうなのを探してみてください。<br>
シーンを変更するときはChangeScene関数、ゲームを終了するときはEndGame関数を呼び出します。<br>
SetFadeは、画面の色調を変更するものです。デフォルト値は(255, 255, 255)です。<br>
Graphicなどで描画されるものの色調は、ここで指定した色調に依存することになります。<br>

<br><h3>【ビヘイバークラス】（内部システム > Behavior.h／.cpp）</h3>
なんかいい名前が思いつかなかったクラスです。<br>
ゲーム中における基本的な振る舞いを行い、シーンもこれを継承して作られています。<br>
画像、音楽、フォントはそれぞれpic、sound、fontという連想配列で保持されており、自由に利用可能です。<br>
シーンを閉じる際に自動ですべてのメモリ開放を行いますので、deleteがいらない利点があります。<br>
また、状態を担う列挙型Stateを定義するための機構が揃っています。<br>

<br><h3>【共通ヘッダ】（内部システム > common.h）</h3>
おおよそすべてのファイルはこれをインクルードしています。<br>
よく使うものたちはすべてインクルードしていますので、これだけ呼び出せば便利そうです。<br>
どこでも使用可能な便利関数などを作るときはここに新たに追加するのも手だと思います。<br>

<br><h3>【画像クラス】（内部システム > Graphic.h／.cpp）</h3>
画像を取り扱うクラスです。<br>
いじるものではありませんが、よく使うことになるでしょう。<br>
ヘッダファイルに使える機能をまとめていますので、参考にしてください。<br>

<br><h3>【音楽クラス】（内部システム > Sound.h／.cpp）</h3>
音楽を取り扱うクラスです。<br>
それぞれBGM、効果音を取り込めるようにしているつもりです。<br>
こちらも画像同様、ヘッダファイルに機能をまとめています。br>

<br><h3>【フォントクラス】（内部システム > Font.h／.cpp）</h3>
フォントを取り扱うクラスです。<br>
フォントを作成してそれで文字を表示する一連の機能を使えるようにします。<br>

<br><h3>【２次元ベクトル】（内部システム > Vector2.h／.cpp）</h3>
Vector2は整数のベクトル、Vector2dは実数のベクトルです。<br>
２次元の値を用いるときは、これを利用したほうがきれいだと思います。<br>

<br><h3>【乱数クラス】（内部システム > Random.h）</h3>
乱数のクラスです。それだけです。<br>
DefaultRand関数で乱数の初期化が行えますが、これはゲーム開始時に自動で呼ばれます。<br>
Rand関数にて乱数を発生させることができます。<br>
SetDefaultRandで任意のシードにて乱数の初期化が行えます。リプレイファイルの作成などに用います。<br>

<br><hr>

<div id = "start"></div>
<h2>色々といじってみよう</h2>
ゲームの初期設定を決めている部分は、共通フォルダ内のInfoData.hです。<br>
開くと、ゲームのタイトルやウィンドウのサイズなどが並べられていることが分かります。<br>
ゲームのタイトルは初めにタイトルバーに表記される文字であり、<br>
途中でタイトルバーの文字を変えることがなければ、ここで決めたゲームタイトルがタイトルバーに表記され続けます。<br>
ウィンドウサイズは、ウィンドウモードの場合は好きなサイズのウィンドウに設定可能です。<br>
Vector2(640, 480)とありますが、これは２次元ベクトル型の値です。<br>
横640、縦480の大きさ、ということでパラメータが２つあるので、<br>
一緒に取り扱えば便利だろうという目的からVector2型を採用しています。<br>
ウィンドウモードフラグは初めtrueになっていますが、これをfalseにするとフルスクリーンになります。<br>
また、初期シーン名称はゲーム開始時のシーンの名前であり、後に変更することになりそうな所です。<br>
<br>
このテンプレートではシーンの遷移でゲームの状態を変えるように作ることを想定しており、<br>
例えばタイトル画面からゲームのメイン画面に遷移し、メニューキーを押せばメニュー画面に遷移、<br>
ゲームが終わればエンディング画面に遷移する、など、様々な画面の遷移として大規模なゲームを表現できます。<br>
初めはMainSceneだけですが、シーンは自由に追加していくことが可能です。<br>
<br>
MainScene.hはメイン画面のヘッダファイル、MainScene.cppはメイン画面のソースファイルです。<br>
クラスで使用されている変数や関数の宣言は全部ヘッダファイルにしておき、<br>
ソースファイルを見なくてもヘッダファイルだけでそのクラスの仕様が分かるように作成するのが分かりやすくて良いと思います。<br>
MainScene.cppを覗くと実装部分が見られます。<br>
コンストラクタにて「テキスト」というフォントを作成し、<br>
そのフォントでDraw関数にて「キャンセルキーで終了します」という文字列を描画しています。<br>
シーンには最低限、シーンの初期設定を行うコンストラクタ、シーン終了時の処理を行うデストラクタ、<br>
毎度呼び出されるUpdate、Drawの4つの関数があります。Updateは状態更新、Drawは描画です。<br>
この中を編集していくことで、ゲームを作成していくことが出来るというわけです。<br>
<br><hr>

<div id = "pic"></div>
<h2>画像を表示してみよう</h2>
今は文字だけしかなくて殺風景なので、画像の表示をしてみましょう。<br>
何か画像を用意してください。bmpだけじゃなく、透過pngなどにも対応しています。<br>
↓用意が面倒な場合は、こちらを保存してください。<br>
<img src = "html_dat\pinkri.png"><br>
保存場所は、vcxprojファイルが置かれている場所です。たくさんcppとかhとか置いてある所です。<br>
そこに画像を放り込んでください。<br>
そこがホームディレクトリになるだけですので、相対パスを用いれば任意のフォルダも参照可能です。<br>
上の画像は<b>「pinkri.png」</b>ですので、適宜画像名を置き換えてください。<br>
<br>
まず、画像を登録する必要がありますので、初期設定を書き加えましょう。<br>
初期設定はMainScene::MainScene（コンストラクタ）で行います。その中に次の一行を加えてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = Graphic::Create("pinkri.png");<br>
</b></td></tr></tbody></table><br>
picは標準で使用可能な画像の連想配列です。picの中身は好きな文字列を指定可能です。<br>
これにて「pinkri.png」の画像が読み込まれ、pic["ぴんくり"]でその画像を参照できるようになります。<br>
<br>
実際に描画してみます。描画はMainScene::Drawで行いますので、<br>
BaseScene::Draw();の直後に次の一行を加えてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->Draw();<br>
</b></td></tr></tbody></table><br>
picはGraphicをポインタで持ってるので、ドットではなくアロー演算子で参照することに注意してください。<br>
Draw関数を呼び出すことにより、画像が描画されます。<br>
２行加えただけですが、これで画像が表示されるはずですので、F5で実行してご確認ください。<br>
画像が指定したパスに存在しなくてもエラーは出ず、画像が出ないだけなので<br>
画像が出なければパスが間違っている可能性があります。<br>
成功しますと、左上を基点として画像が描画されていることが確認できます。<br>
<br>
ちなみにBaseScene::Draw();は基底クラスのDrawを呼び出すもので、Updateにも似たものありますけれど<br>
それらは必ず行頭に置くようにしてください。これによって、画面の色調変更などを実現することが可能になります。<br>
<br>
ど真ん中に表示したいので、初期位置を変更します。<br>
画像の登録の行を次のように変更してみてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = Graphic::Create("pinkri.png", Vector2d(320, 240), true);<br>
</b></td></tr></tbody></table><br>
第二引数は画像の初期位置です。第三引数は中心座標を有効にするという意味です。<br>
これがfalseだと（デフォルトではfalseです）左上座標が採用されますが、<br>
それだと不便な場合はここをtrueにしてください。ちゃんとど真ん中に表示されますね。<br>
<br>
ただ、(320, 240)という座標は画面サイズが(640, 480)だから真ん中になるのであって<br>
常に真ん中を指すわけじゃないから不便だよ、というご意見もあるでしょうから<br>
common::GetWindowCenter() でウィンドウの中心座標をVector2d型で返してくれるようにしています。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = Graphic::Create("pinkri.png", common::GetWindowCenter(), true);<br>
</b></td></tr></tbody></table><br>
確かに、この方が分かりやすいかもしれませんね。<br>
<br>
Vector2dは実数の２次元ベクトル型であり、x座標とy座標をまとめて扱うものです。<br>
整数を用いる場合はVector2にしてください。ただし、画像の座標は実数でなければなりません。<br>
<br>
試しにこの画像の登録の直後に<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->fade = 0;<br>
	pic["ぴんくり"]->zoom = 0;<br>
</b></td></tr></tbody></table><br>
を加え、MainScene::Updateのどこかに<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->angle += 0.1;<br>
	pic["ぴんくり"]->zoom++;<br>
	pic["ぴんくり"]->fade++;<br>
</b></td></tr></tbody></table><br>
を入れてみてください。<br>
Updateは状態の更新を行うように設計している関数です。<br>
画像が透明な状態から徐々に、回転しながら大きくなりつつ表示されていく様子が見られると思います。<br>
要領はこれにて良いかと思います。<br>
コンストラクタにてシーン開始時の初期設定を行い、Updateで更新、Drawで描画します。<br>
その呼び出し間隔はリフレッシュレートに依存し、60Hzであれば1秒間に60回行われます。<br>
UpdateしてDraw、というのを1秒間に60回繰り返すということです。<br>
UpdateとDrawを分ける必要ないんじゃないかと思われるかもしれませんが、<br>
分けたほうが分かりやすいだろうという目的で分けているだけなので、<br>
いらない場合はどちらか一方にのみ書き連ねていっても構いません。<br>
<br>
ちなみに、MainScene::~MainSceneはデストラクタです。シーン終了時に呼び出されます。<br>
メモリ確保したものの後始末に利用されると良いですが、<br>
標準で提供しているpicというのは自動で消去されるようにしていますので、後始末は不要です。<br>
シーン中にどうしても手動で削除したい場合は、DeletePic()関数で削除ができます。<br>

<br><hr>

<div id = "text"></div>
<h2>文字を設定してみよう</h2>
今度は、文字を設定してみましょう。<br>
コンストラクタにもとからあるこの一行は「テキスト」という名前のフォントを作成していることを意味しています。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"] = Font::Create("メイリオ", Vector2d(10, 10), 24);<br>
</b></td></tr></tbody></table><br>
fontはpic同様、標準で使える連想配列です。<br>
第一引数は使用するフォントの種類名、第二引数は表示位置、第三引数は文字の大きさです。<br>
さらに第四引数で文字の太さ、第五引数でエッジの有無、第六引数でアンチエイリアスの設定ができます。<br>
それらを指定しない場合、デフォルトでエッジなしのアンチエイリアスありが指定されます。<br>
引数の数値を変えて実行、確認してみてください。文字サイズ24の所を100とかにすると、どでかくなります。<br>
<br>
文字にはエッジをつけることも可能です。フォントを作成する部分を以下のように変更してみてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"] = Font::Create("メイリオ", Vector2d(10, 10), 32, 2, true);<br>
	font["テキスト"]->SetColor(255, 255, 0);<br>
	font["テキスト"]->SetEdgeColor(255, 0, 0);<br>
</b></td></tr></tbody></table><br>
文字の大きさを32、太さを2にして、第五引数にtrueを入れました。<br>
第五引数をtrueにすると、エッジが有効になります。<br>
SetColorで文字の色を変え、SetEdgeColorでエッジの色を変えられます。<br>
デフォルトでは文字が白、エッジが黒になっています。<br>
数値は赤、緑、青の輝度ですが、これは多分良いでしょう。<br>
実行してみると、赤いエッジのついた黄色い文字が表示されることが確認できます。<br>
<br>
Draw関数では、作成したフォントを表示しています。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->Print("キャンセルキーで終了します");<br>
</b></td></tr></tbody></table><br>
fontはポインタで持ってるので、ドットではなくアロー演算子で参照することに注意してください。<br>
Print関数の引数に表示したい文字を入れると表示できます。<br>
引数はstring型ですので、string型の変数を用意すれば、引数に変数を用いることももちろん可能です。<br>
<br>
では、今度は文字を動かしてみましょう。<br>
Update関数内のどこかにこの行を追加してみてください。<br>
実際どこでもいいですが、出来るだけBaseScene::Update();より前には何も入れないでください。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->pos.y++;<br>
</b></td></tr></tbody></table><br>
posはフォントの表示座標です。そのy座標が1ずつ上がっていくということになります。<br>
画面はy座標が上がると数学の座標平面と違って下に下がっていくので、<br>
これによって文字が下に下がっていくことになります。<br>
<br>
さらに、表示する文字を変えて現在のテキストのy座標を表示できるようにしてみます。<br>
MainScene.hのメンバーに、表示するテキストの内容を保持する変数を加えてみましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	string text;	// 表示するテキスト<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>
publicの前にstring text;を一行追加しました。これでメイン画面はstring型のtextを保持できるようになります。<br>
MainScene.cppに戻り、Updateに次の二行を追加しましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	int value = font["テキスト"]->pos.ToInt().y;<br>
	text = "今のy座標は" + common::convert&lt;int, string&gt;(value) + "です。";<br>
</b></td></tr></tbody></table><br>
font["テキスト"]->pos.ToInt()とすると、posをVector2d型（実数）からVector2型（整数）に変換できます。<br>
保持しているのは実数ですが、整数を表示したいので整数にしました。そのy座標をvalueに入れます。<br>
このvalueは計算用に使うだけなのでMainSceneのメンバーにしないでUpdateだけで宣言していいです。<br>
変数増えるとややこしくなりますからね＾＾；<br>
次に、textに表示するテキストを入れます。<br>
common::convert&lt;int, string&gt;(value)とすると、valueを整数から文字列に変換できます。<br>
convertは、int型をstring型に変換する文字列変換関数です。逆に&lt;string, int&gt;とすれば文字列を数値に変換できます。<br>
そして、Draw関数でこのtextを表示するように設定します。<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->Print(text);<br>
</b></td></tr></tbody></table><br>
これで実行すれば、文字が下に下がりながら、更新されるy座標の値を文字列として表示する様子が見られるでしょう。<br>
ちなみに、これぐらいであれば全部一行でまとめて、<br>
<br><table border = "2"><tbody><tr><td><b>
	font["テキスト"]->Print("今のy座標は" + common::convert&lt;int, string&gt;(font["テキスト"]->pos.ToInt().y) + "です。");<br>
</b></td></tr></tbody></table><br>
としても良いと思いますが、あんまりにも長くなる場合は見づらくなるので<br>
一旦変数におくとか、見やすくしちゃっていいと思います。<br>

<br><hr>

<div id = "key"></div>
<h2>キー入力対応させてみよう</h2>
キー入力は簡単に実現できます。<br>
プロジェクト作成時にUpdate内に<br>
<br><table border = "2"><tbody><tr><td><b>
	if (KeyInput::GetKey(Cancel, PushedNow)){<br>
	&nbsp	EndGame();<br>
	}<br>
</b></td></tr></tbody></table><br>
というのがありますが、これはキャンセルキーを押すとゲームを終了するという処理です。<br>
見てそのまんまだと思うのですが、いかがでしょうか。<br>
<b>KeyInput::GetKey(キーの種類, 取得する状態)</b><br>
とすると、そのキーがその状態にあるかどうかを調べてtrueかfalseか返してくれます。<br>
初めから提供しているキーはKeyInput.hにあるように、以下の通りです。<br>
<br><table border = "2"><tbody><tr><td><b>
	Down,	// ↓<br>
	Left,	// ←<br>
	Right,	// →<br>
	Up,	// ↑<br>
	OK,	// 決定キー<br>
	Cancel,	// キャンセルキー<br>
	Shift,	// シフトキー<br>
	Ctrl,	// コントロールキー<br>
</b></td></tr></tbody></table><br>
KeyTypeの列挙型として保持しています。ジョイスティックパッドにも実は対応しています。<br>
KeyInput::GetKey関数の第一引数にどれかキーの種類を入れて、<br>
第二引数には取得する状態を入れます。<br>
取得する状態はKeyStateの列挙型として以下のように保持しています。<br>
<br><table border = "2"><tbody><tr><td><b>
	PushedNow,	// 押した瞬間<br>
	HasBePushed,	// 押している状態<br>
	ReleaseNow,	// 離した瞬間<br>
	NeverPushed,	// 離している状態<br>
</b></td></tr></tbody></table><br>
キャンセルを押したら終了、という機能はキャンセルキーを押した瞬間を得られればいいので<br>
先ほどのようにPushedNowを第二引数とすればよいですが、<br>
キャラクターの移動など、押しっぱなしでも反応させたい場合はHasBePushedが有効です。<br>
<br>
では実際に、画像を動かしてみましょう。<br>
まず、コンストラクタでは画像の取り込みのみ行うようにします。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"] = new Graphic("pinkri.png", common::GetWindowCenter(), true);
</b></td></tr></tbody></table><br>
Drawでは以下の一行。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ぴんくり"]->Draw();
</b></td></tr></tbody></table><br>
これで画像がど真ん中に表示される、ということでしたが、<br>
今度はUpdateに、キー入力に応じて画像が移動する処理を追加しましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	if (KeyInput::GetKey(Left, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.x -= 3;<br>
	}<br>
	if (KeyInput::GetKey(Right, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.x += 3;<br>
	}<br>
	if (KeyInput::GetKey(Up, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.y -= 3;<br>
	}<br>
	if (KeyInput::GetKey(Down, HasBePushed)){<br>
	&nbsp	pic["ぴんくり"]->pos.y += 3;<br>
	}<br>
</b></td></tr></tbody></table><br>
何をしているかはお分かりでしょう。<br>
キーを押すと、座標を足し引きしているのです。<br>
3を足し引きするので、リフレッシュレートが60Hzなら、1／60秒で3ドット移動します。<br>

<br><hr>

<div id = "sound"></div>
<h2>音楽を再生してみよう</h2>
BGMも画像と似たように扱うことができます。<br>
以下はBGM.mp3というファイルを読み込んで再生するサンプルです。<br>
コンストラクタに下のように書いてみましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["BGM"] = Sound::CreateBGM("BGM.mp3");<br>
	sound["BGM"]->Play();<br>
</b></td></tr></tbody></table><br>
picがsoundに、GraphicがBGMになったぐらいです。<br>
読み込んだ直後にPlay()（再生）を実行しています。これで読み込んだBGMが再生されます。<br>
<b>Play()はUpdateやDrawに直に置くのはやめてください。</b><br>
画像はパラパラ漫画のように連続して描画することで動きを表現するものですが、<br>
音楽は再生を一度行えば鳴り続けるもので、<br>
Play()を連続で実行してしまうと連続で再生開始としてしまってえらいことになります。<br>
<br>
効果音の場合は以下のようになります。SE.wavを読み込んで再生する例です。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["効果音"] = Sound::CreateSE("SE.wav");<br>
	sound["効果音"]->Play();<br>
</b></td></tr></tbody></table><br>
BGMがSEに変わっただけです。<br>
BGMとSEの違いは再生位置が終端までいってループするか否か、だけです。<br>
効果音は再生したいタイミングでPlay()を実行してくださればOKです。<br>
Stop()で停止してから再度Play()をすると、どちらも再生位置は初めからに戻ります。<br>
引数で再生位置を設定することも可能です。<br>
ここで、Stop(true)とすると再生位置を保持したまま停止できます。<br>
Play()は引数を省略すると保持した再生位置から再開するので、<br>
Stop(true)をしてからPlay()をすれば、停止した再生位置から再開できます。<br>
<br>
BGMはループ再生するように設定されますが、ループしたときに途中からループさせるには第二引数に値を入れます。<br>
<br><table border = "2"><tbody><tr><td><b>
	sound["BGM"] = Sound::CreateBGM("BGM.mp3", 5000);<br>
</b></td></tr></tbody></table><br>
↑BGM.mp3の再生位置が終端までいったら、再生位置5秒の位置からループするという設定です。<br>
第二引数にはループする位置をミリ秒単位で指定します。5000ミリ秒＝5秒ということです。<br>
<br>
再生を停止させるにはStop()を用います。<br>
シーンが切り替わるとpicとsoundはすべて消去されるのでBGMなども自動で停止してしまいますが、<br>
共通データ（CommonData::UnSaveData）にBGMを保持しておいてそれを再生するようにすれば<br>
シーンをまたいでもBGMを再生し続けられるというテクニックもあります。<br>
ただし、BGMの初期化をCommonData::Initializeで行う場合は、<br>
メモリリークを防ぐためにゲーム終了時の処理（CommonData::Finalization）にてメモリ開放してください。<br>

<br><hr>

<div id = "scene"></div>
<h2>シーンを追加してみよう</h2>
シーンとは画面のようなものです。タイトル画面でも追加してみましょう。<br>
<b>「TitleScene」</b>という名前で新たなクラスを作成します。<br>
ソリューションエクスプローラーのどこかてきとうな所で右クリックすると「追加 > クラス」というのが選択できるので<br>
それでC++クラスを選択したらウィザードが開きますから、<br>
クラス名に「TitleScene」を、基底クラスに「BaseScene」を入力してください。<br>
シーンの基底クラスはすべて「BaseScene」です。<br>
すると、「TitleScene.h」と「TitleScene.cpp」が作成されますから、<br>
分かりやすいようにそれぞれ「シーン」フォルダに入れておいてください。<br>
<br>
後はMainSceneを真似て同じような形にすればOKです。<br>
TitleScene.hのTitleSceneクラスのpublic部分に次の２行を追加してください。<br>
<br><table border = "2"><tbody><tr><td><b>
	void Update() override;<br>
	void Draw() override;<br>
</b></td></tr></tbody></table><br>
これにより、BaseSceneのUpdateとDrawをオーバーライドします。<br>
overrideはオーバーライドするということの強調ですが、なくても構いません。<br>
次に、TitleScene.cppのどこかに次の行を追加してください。<br>
<br><table border = "2"><tbody><tr><td><b>
	void TitleScene::Update(){<br>
	&nbsp	BaseScene::Update();<br>
	}<br>
	<br>
	void TitleScene::Draw(){<br>
	&nbsp	BaseScene::Draw();<br>
	}<br>
</b></td></tr></tbody></table><br>
これで、Update関数とDraw関数が定義できました。<br>
BaseScene::Updateは基底クラスのUpdateを、<br>
BaseScene::Drawは基底クラスのDrawをそれぞれ実行するものです。一応常に入れておいてください。<br>
これでTitleSceneの骨格ができました。MainSceneと同じような形になっていることが確認できます。<br>
<br>
そして、TitleSceneをシーンとして登録するためにScene.hを開きます。<br>
一番上にMainSceneのインクルードがあるので、その次の行にこれを入れてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	#include "TitleScene.h"
</b></td></tr></tbody></table><br>
そして、GetSceneObject関数内でMainSceneの記法に従って次の行を追加してください。<br>
<br><table border = "2"><tbody><tr><td><b>
	if (name == "Title")	ret = new TitleScene();
</b></td></tr></tbody></table><br>
これにて、「Title」という名前でTitleSceneのインスタンスを生成できるようになりました。<br>
実際にシーンを切り替えるときはChangeScene("Title")とすればタイトル画面に遷移します。<br>
<br>
それではタイトル画面を表示しましょう。<br>
何でもいいですが、例えば↓この画像をタイトル画面とします。<br>
<img src = "html_dat\title.jpg"><br>
<b>「title.jpg」</b>という名前の、(640, 480)のサイズの画像です。<br>
ついでにこんなのも作りました。<br>
<img src = "html_dat\enter.png"><br>
この画像は<b>「enter.png」</b>です。「Enter押してね」って書いてます。<br>
これの透明度を上げたり下げたりして、それっぽく見せることにします。<br>
「title.jpg」と「enter.png」を読み込んで、Drawにて描画、<br>
「Enter押してね」の方はUpdateにて透明度を上げたり下げたりします。<br>
決定キーを押せば、Main画面に遷移する、ということをしましょう。<br>
<br>
↓こんな感じです。<br>
<br><table border = "2"><tbody><tr><td><b>
	#include "TitleScene.h"<br>
	<br>
	TitleScene::TitleScene(){<br>
	&nbsp	pic["タイトル"] = Graphic::Create("title.jpg");<br>
	&nbsp	pic["押してね"] = Graphic::Create("enter.png", Vector2d(common::GetWindowCenter().x, 400), true);<br>
	}<br>
	<br>
	TitleScene::~TitleScene(){<br>
	}<br>
	<br>
	void TitleScene::Update(){<br>
	&nbsp	BaseScene::Update();<br>
	&nbsp	pic["押してね"]->fade = 128 - 128.0 * cos(0.1 * GetSceneTime());<br>
	&nbsp	if (KeyInput::GetKey(OK, PushedNow)){<br>
	&nbsp	&nbsp	ChangeScene("Main");<br>
	&nbsp	}<br>
	}<br>
	<br>
	void TitleScene::Draw(){<br>
	&nbsp	BaseScene::Draw();<br>
	&nbsp	pic["タイトル"]->Draw();<br>
	&nbsp	pic["押してね"]->Draw();<br>
	}<br>
</b></td></tr></tbody></table><br>
最後に、初期シーンを「Main」から「Title」に変えたいので、<br>
InfoData.hを開きましてDefaultScene()の中身を「Main」から「Title」に変えます。<br>
これにより、初期シーンがタイトル画面になり、決定キーを押せばメイン画面に遷移します。<br>
実際にビルドして実行してみてください。ゲームっぽくなってきました。<br>

<br><hr>

<div id = "div"></div>
<h2>画像の分割読み込み</h2>
画像はGraphic::Createとすれば読み込みが可能ですが、このような画像の場合は単体ずつ読み込むのは非効率です。<br>
<img src = "html_dat\baysuke.png">&copy;Gx2s<br>
画像は<b>「baysuke.png」</b>です。こちらの画像の場合は分割読み込みが有効です。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ベイ助"] = Graphic::Create("baysuke.png", Vector2(32, 48), Vector2(4, 4), common::GetWindowCenter(), true);<br>
</b></td></tr></tbody></table><br>
picDivも標準装備している、分割画像を格納する変数です。vector<Graphic*>で格納しています。<br>
要するに、Graphicポインタの配列です。<br>
分割読み込み時には、オーバーロードしたCreate関数を用います。<br>
第二引数に分割時の一つ分の画像サイズを、第三引数に分割する数（横と縦）をそれぞれ入れれば、<br>
これは分割読み込みと認識されて、分割読み込みされた画像の情報が格納されます。<br>
この場合は「baysuke.png」を分割したときの一つ分の大きさは(32, 48)、これを横４つ、縦４つにそれぞれ分割したいので<br>
以上のような構文で入力をします。それ以降の引数は単体読み込みと同じです。<br>
これをMainSceneのコンストラクタに入れて登録しておきましょう。<br>
次に、描画する際には分割されて画像が１６枚になっているので、どれを描画するかを指定する必要があります。<br>
これは画像の配列になっていますから、picDiv["ベイ助"]を配列として扱えばOKです。
番号は左上を0番として、右にいくにつれ1、2、…、右端までいったら次の段へ、…という具合で付きます。<br>
この場合は１６枚に分割しているので、一番右下は15番ということになりますね。<br>
15番を描画したいときは、<br>
<br><table border = "2"><tbody><tr><td><b>
	picDiv["ベイ助"][15]->Draw();<br>
</b></td></tr></tbody></table><br>
となります。<br>
動いてるっぽく見せたいので、試しにDraw内に次のように書いてみてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	int id = (GetSceneTime() / 15) % 16;<br>
	picDiv["ベイ助"][id]->Draw();<br>
</b></td></tr></tbody></table><br>
GetSceneTimeで、シーンが始まってからの時間（フレーム単位）を取得できます。<br>
それを15で割って16で割った余りを描画する番号idとして決め、描画させてみます。<br>
こうすると、0番、1番、…、15番、と順に表示され、0番に戻る、というのがループされます。<br>
ただそれだけの例ですが、動いてる画像が表示されるのでよりゲームらしくなってきてないでしょうか。<br>
<br>
キャラクターを４方向に歩かせるサンプルです。<br>
<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	int step;	// 足踏みの時間<br>
&nbsp	int id;	// 描画する画像の番号<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene(){<br>
&nbsp	picDiv["ベイ助"] = Graphic::Create("baysuke.png", Vector2(32, 48), Vector2(4, 4), common::GetWindowCenter(), true);<br>
&nbsp	step = 0;<br>
&nbsp	id = 0;<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (KeyInput::GetKey(Left, HasBePushed)){<br>
&nbsp	&nbsp	picDiv["ベイ助"]->pos.x -= 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 4;<br>
&nbsp	}<br>
&nbsp	else if (KeyInput::GetKey(Right, HasBePushed)){<br>
&nbsp	&nbsp	picDiv["ベイ助"]->pos.x += 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 8;<br>
&nbsp	}<br>
&nbsp	else if (KeyInput::GetKey(Up, HasBePushed)){<br>
&nbsp	&nbsp	picDiv["ベイ助"]->pos.y -= 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 12;<br>
&nbsp	}<br>
&nbsp	else if (KeyInput::GetKey(Down, HasBePushed)){<br>
&nbsp	&nbsp	picDiv["ベイ助"]->pos.y += 3;<br>
&nbsp	&nbsp	step++;<br>
&nbsp	&nbsp	id = 0;<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	step = 0;<br>
&nbsp	&nbsp	id = id / 4 * 4;	// 4で割ると小数点以下切捨てされることを利用して番号を戻している<br>
&nbsp	}<br>
&nbsp	id += ((step + 7) / 8) % 4;	// 足踏み時間に応じて番号を加算<br>
<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	picDiv["ベイ助"][id]->Draw();<br>
}<br>
</b></td></tr></tbody></table><br>
アニメーションなどを作成する場合は、このように一つの画像にまとめて分割した方が便利でしょう。<br>

<br><hr>

<div id = "handle"></div>
<h2>画像のハンドル指定読み込み</h2>
単体読み込み、分割読み込みはいずれも一つのオブジェクトが必ず画像を持っているような形でしたが、<br>
シューティングゲームなど、同じ画像を大量に扱う際にはこれはメモリがもったいなさすぎます。<br>
同じ画像を複数のGraphicオブジェクトが兼用できるようにしたいものです。<br>
<br>
画像は読み込み時にハンドルという番号が与えられ、内部ではそれを用いて画像を描画しています。<br>
ですから、このハンドルを兼用できれば複数のオブジェクトが同一の画像を扱うことができるようになります。<br>
<br>
<img src = "html_dat\bullet.png"><br>
<br>
↑<b>「bullet.png」</b>です。例ではこれを使用することにします。<br>
画像のハンドルを取得するには、以下のように書きます。<br>
<br><table border = "2"><tbody><tr><td><b>
	int* handle = Graphic::CreateHandle("bullet.png");<br>
</b></td></tr></tbody></table><br>
Graphic::CreateHandleにより、画像のハンドルを取得できます。<br>
これは分割読み込みに対応できるようint型のポインタとして出力されます。<br>
ハンドルを用いてGraphicオブジェクトを生成するには、以下のように書きます。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["弾"] = new Graphic(handle);
</b></td></tr></tbody></table><br>
パスの部分をハンドルに置き換えればいいだけです。<br>
後はハンドルを使いまわしてGraphicオブジェクトを大量生成することが可能です。<br>
<br>
注意が一つあります。<br>
ハンドルで取得した画像というのは<b>Graphicオブジェクトを削除しても消えません。</b><br>
実際に削除するためにはこれを入れてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	Graphic::DeleteHandle(handle);
</b></td></tr></tbody></table><br>
handleにはハンドルの変数を入れます。これにより、画像を削除してメモリ開放できます。<br>
これを入れない限りは、<b>シーンを変更しても消えないので、どこかで必ず削除するようにしてください。</b><br>
シーンのデストラクタに入れておくのが良いと思います。<br>
これに限らず、picで保持しないGraphic型変数は勝手には消えませんから、十分注意してください。<br>
<br>
弾画像を大量に発生させてみましょう。<br>
以下は1000個の弾を中心から一斉に分散させるサンプルです。<br>
きれいと思うか、気持ち悪いと思うかは、人を選びそうですが＾＾；<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	Graphic* bullet[1000];	// 弾<br>
&nbsp	Vector2d bullet_pos[1000];	// 弾の座標（実数）<br>
&nbsp	double bullet_speed[1000];	// 弾の速度<br>
&nbsp	int* handle;	// 弾画像のハンドル<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene(){<br>
&nbsp	handle = Graphic::CreateHandle("bullet.png");	// 弾画像のハンドル取得<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	bullet[i] = new Graphic(handle, common::GetWindowCenter(), true);	// ハンドルを割り当て<br>
&nbsp	&nbsp	bullet[i]->angle = 180.0 * Random::Rand(360) / 3.141592;	// 投射角度を360°からランダムに指定<br>
&nbsp	&nbsp	bullet_pos[i].x = static_cast<double>(bullet[i]->pos.x);	// x座標の実数値を保持<br>
&nbsp	&nbsp	bullet_pos[i].y = static_cast<double>(bullet[i]->pos.y);	// y座標の実数値を保持<br>
&nbsp	&nbsp	bullet_speed[i] = 0.02 * Random::Rand(100);	// 弾のスピードをランダムに指定<br>
&nbsp	&nbsp	bullet[i]->fade = 0;	// 弾は初め透明とする<br>
&nbsp	}<br>
}<br>
<br>
MainScene::~MainScene(){<br>
&nbsp	Graphic::DeleteHandle(handle);	// シーン終了時、必ずメモリ開放すること<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	delete bullet[i];	// 弾のGraphicオブジェクトもきちんと削除してメモリ開放すること<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	// 弾の位置を角度とスピードから、実数値で計算<br>
&nbsp	&nbsp	bullet_pos[i].x += bullet_speed[i] * cos(bullet[i]->angle);<br>
&nbsp	&nbsp	bullet_pos[i].y -= bullet_speed[i] * sin(bullet[i]->angle);<br>
<br>
&nbsp	&nbsp	// 弾画像の座標に計算した結果を渡す<br>
&nbsp	&nbsp	bullet[i]->pos.x = static_cast&lt;int&gt;(bullet_pos[i].x);<br>
&nbsp	&nbsp	bullet[i]->pos.y = static_cast&lt;int&gt;(bullet_pos[i].y);<br>
<br>
&nbsp	&nbsp	// 不透明度を上げていく<br>
&nbsp	&nbsp	bullet[i]->fade++;<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	for (int i = 0; i < 1000; i++){<br>
&nbsp	&nbsp	bullet[i]->Draw();	// すべて描画<br>
&nbsp	}<br>
}<br>
</b></td></tr></tbody></table><br>
弾の座標をMainSceneも保持していますが、これは仕方なくです……<br>
本当は実数値で座標を持ちたかったのですが、Graphicでは座標を整数値で管理しているので<br>
実数値で計算したものをGraphicの座標に渡してやることをしています。<br>
Graphicを実数値に対応させればいいのですが……やるかやらないか分かりません。<br>
<br>
分割読み込み画像のハンドル取得は以下のようにします。<br>
<br><table border = "2"><tbody><tr><td><b>
	int* handle = Graphic::CreateHandle("baysuke.png", Vector2(32, 48), Vector2(4, 4));
</b></td></tr></tbody></table><br>
第二引数に一つ分の画像サイズ、第三引数に分割数を入れれば、分割読み込み画像のハンドルを取得できます。<br>
これを用いてGraphicのインスタンス化をするときは、一つ分の大きさや分割数は必要ありません。<br>
<br><table border = "2"><tbody><tr><td><b>
	pic["ベイ助"] = new Graphic(handle);
</b></td></tr></tbody></table><br>
単体読み込みのハンドル指定とまったく同じように扱うことができます。<br>
単体のときと同様、削除時はGraphic::DeleteHandle(handle)を忘れないようにご注意下さい。<br>

<br><hr>

<div id = "divGraphic"></div>
<h2>画像インスタンスを分割する</h2>
あ<br>
<br><hr>

<div id = "motion"></div>
<h2>複雑な動きをさせてみよう</h2>
てきすと<br>
<br><hr>

<div id = "state"></div>
<h2>クラスに状態を設定する</h2>
てきすと<br>
<br><hr>

<div id = "screen"></div>
<h2>スクリーンモードを変更しよう</h2>
InfoDataをいじれば初期設定をフルスクリーンにすることができますが、<br>
ゲームの実行中にスクリーンモードを変更するときは注意が必要です。<br>
<b>ChangeWindowMode(true)</b>でウィンドウモードに、<br>
<b>ChangeWindowMode(false)</b>でフルスクリーンに変更できますが、<br>
その際、<b>すべてのグラフィックデータが消去されてしまいます。</b><br>
ですので、実際に使用する際は直後に画像を再読み込みする処理を入れるなどの工夫をしてください。<br>

<br><hr>

<div id = "save"></div>
<h2>セーブ・ロード機能を作ろう</h2>
ゲームのセーブデータは、それぞれのゲームによって異なります。<br>
ここでは最も単純に、一つの変数をテキストに保存するというのを実現してみましょう。<br>
Enterキーを押すと増える変数で、その変数値はゲームを終了してもテキストに保持されるとします。<br>
<br>
まず、CommonData.hを開き、空っぽのSaveData構造体の中にこれを追加します。<br>
<br><table border = "2"><tbody><tr><td><b>
	int enterNum;	// Enterを押した回数
</b></td></tr></tbody></table><br>
この共通データは、CommonData::saveData.enterNumとしてどこででも参照が可能です。<br>
では今度はCommonData.cppを開きましょう。<br>
ゲームが始まったときにCommonData::Initialize関数が実行されます。<br>
これは、共通データの初期値を決めるものです。セーブデータがない状態の値と考えて良いです。<br>
CommonData::Initializeの中に以下を追加しましょう。<br>
<br><table border = "2"><tbody><tr><td><b>
	saveData.enterNum = 0;
</b></td></tr></tbody></table><br>
セーブデータに用いられているenterNumは、初めは0とします。<br>
<br>
それでは、セーブとロードの関数を作成しましょう。今は空っぽのままになっています。<br>
テキストに変数を読み書きするだけなので、C++の標準的な書き方でOKです。<br>
例えば以下のようになるでしょう。<br>
<br><table border = "2"><tbody><tr><td><b>
bool CommonData::Save(string path){<br>
&nbsp	ofstream ofs(path);<br>
&nbsp	bool ret = !ofs.fail();<br>
&nbsp	if (ret){<br>
&nbsp	&nbsp	ofs << saveData.enterNum;<br>
&nbsp	}<br>
&nbsp	return ret;<br>
}<br>
<br>
bool CommonData::Load(string path){<br>
&nbsp	ifstream ifs(path);<br>
&nbsp	bool ret = !ifs.fail();<br>
&nbsp	if (ret){<br>
&nbsp	&nbsp	stringstream ss;<br>
&nbsp	&nbsp	string buf;<br>
&nbsp	&nbsp	getline(ifs, buf);<br>
&nbsp	&nbsp	ss << buf;<br>
&nbsp	&nbsp	ss >> saveData.enterNum;<br>
&nbsp	}<br>
&nbsp	return ret;<br>
}<br>
</b></td></tr></tbody></table><br>
これで、enterNumを読み書きする機構が完成しました。<br>
実際にゲームに組み込んでみましょう。<br>
<br>
MainSceneで実験をしてみたいと思います。<br>
比較用に、セーブしないただのenterNumをMainSceneに持たせてみましょう。<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	int enterNum;	// 今回Enterを押した回数<br>
&nbsp	int enterTime;	// 次にEnterを押せるようになるまでの時間<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene(){<br>
&nbsp	SetFontSize(32);<br>
<br>
&nbsp	enterNum = 0;<br>
&nbsp	enterTime = 0;<br>
&nbsp	pic["ぴんくり"] = new Graphic("pinkri.png", common::GetWindowCenter(), true);<br>
&nbsp	CommonData::Load("セーブデータ.txt");	// ロード<br>
}<br>
<br>
MainScene::~MainScene(){<br>
&nbsp	CommonData::Save("セーブデータ.txt");	// セーブ<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (KeyInput::GetKey(OK, PushedNow) && enterTime == 0){<br>
&nbsp	&nbsp	enterNum++;	// 今回のEnter回数（終了時に消える）<br>
&nbsp	&nbsp	CommonData::saveData.enterNum++;	// Enter回数の総数（セーブされる）<br>
&nbsp	&nbsp	enterTime = 30;<br>
&nbsp	}<br>
<br>
&nbsp	if (KeyInput::GetKey(Cancel, PushedNow)){<br>
&nbsp	&nbsp	EndGame();<br>
&nbsp	}<br>
<br>
&nbsp	if (enterTime > 0){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.y = 100.0 / (15 * 15) * (enterTime - 15) * (enterTime - 15) + common::GetWindowCenter().y - 100.0;<br>
&nbsp	&nbsp	enterTime--;<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	pic["ぴんくり"]->Draw();<br>
<br>
&nbsp	DrawFormatString(10, 10, GetColor(255, 255, 255), "今回Enterを押した回数　　：%d", enterNum);<br>
&nbsp	DrawFormatString(10, 40, GetColor(255, 255, 255), "今までにEnterを押した総数：%d", CommonData::saveData.enterNum);<br>
}<br>
</b></td></tr></tbody></table><br>
Enterを押すと画像がジャンプするようにしました。<br>
コンストラクタにてLoadを行い、「セーブデータ.txt」を読み込みます。<br>
もし読み込みに失敗したとき（初回起動でファイルが存在しない場合など）は何事も無くスルーされます。<br>
テキストを無事読み込めたら、数値を取り込んでゲームに反映させます。<br>
また、デストラクタでSaveを行うようにしました。<br>
つまり、ゲームを終了させたときにEnterを押した総数が保存されるようになります。<br>
<br>
セーブデータの作り方は様々ですので、ゲームの様態に合わせて作成してみてください。<br>
ハッシュなどを用いてセーブデータの改竄を防ぐなどといったテクニックもあります。<br>

<br><hr>

<div id = "keyconfig"></div>
<h2>キー割り当ての変更</h2>
ゲーム中にキー割り当てを変更することもできます。<br>
キー入力の判定条件はラムダ式で保持されており、<br>
判定条件を変えるときは対応するキーの判定条件に新たなラムダ式をセットしてやればOKです。<br>
<br>
以下は、Enterを押すと上下左右のキーの判定条件が反転するサンプルです。<br>

<br><table border = "2"><tbody><tr><th>MainScene.h</th></tr><tr><td><b>
#pragma once<br>
#include "BaseScene.h"<br>
<br>
// ゲーム画面クラス<br>
class MainScene : public BaseScene{<br>
&nbsp	bool reverseFlg;	// 反転フラグ<br>
&nbsp	void SetKeys();	// キーの判定条件のセット<br>
public:<br>
&nbsp	MainScene();	// コンストラクタ<br>
&nbsp	~MainScene();	// デストラクタ<br>
&nbsp	void Update() override;	// 更新<br>
&nbsp	void Draw() override;	// 描画<br>
};<br>
</b></td></tr></tbody></table><br>

<br><table border = "2"><tbody><tr><th>MainScene.cpp</th></tr><tr><td><b>
#include "MainScene.h"<br>
<br>
MainScene::MainScene(){<br>
&nbsp	SetFontSize(32);<br>
&nbsp	pic["ぴんくり"] = new Graphic("pinkri.png", common::GetWindowCenter(), true);<br>
&nbsp	reverseFlg = false;<br>
&nbsp	SetKeys();<br>
}<br>
<br>
MainScene::~MainScene(){<br>
}<br>
<br>
void MainScene::Update(){<br>
&nbsp	BaseScene::Update();<br>
<br>
&nbsp	if (KeyInput::GetKey(Left, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.x -= 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(Right, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.x += 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(Up, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.y -= 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(Down, HasBePushed)){<br>
&nbsp	&nbsp	pic["ぴんくり"]->pos.y += 3;<br>
&nbsp	}<br>
&nbsp	if (KeyInput::GetKey(OK, PushedNow)){<br>
&nbsp	&nbsp	reverseFlg ^= 1;	// 反転<br>
&nbsp	&nbsp	SetKeys();<br>
&nbsp	}<br>
&nbsp}<br>
<br>
void MainScene::Draw(){<br>
&nbsp	BaseScene::Draw();<br>
<br>
&nbsp	pic["ぴんくり"]->Draw();<br>
<br>
&nbsp	if (!reverseFlg){<br>
&nbsp	&nbsp	DrawFormatString(10, 10, GetColor(255, 255, 255), "通常");<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	DrawFormatString(10, 10, GetColor(255, 255, 255), "反転");<br>
&nbsp	}<br>
}<br>
<br>
void MainScene::SetKeys(){<br>
&nbsp	if (!reverseFlg){<br>
&nbsp	&nbsp	// 通常<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Left, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_LEFT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Right, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_RIGHT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Up, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_UP) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Down, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_DOWN) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	}<br>
&nbsp	else{<br>
&nbsp	&nbsp	// 反転<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Left, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_RIGHT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Right, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_LEFT) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Up, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_DOWN) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	&nbsp	KeyInput::SetKeyCond(Down, []{<br>
&nbsp	&nbsp	&nbsp	return CheckHitKey(KEY_INPUT_UP) != 0;<br>
&nbsp	&nbsp	});<br>
&nbsp	}<br>
}<br>
</b></td></tr></tbody></table><br>

もう一つ、CopyKeyCond関数というのもあります。これは別のキーの判定条件をコピーする関数です。<br>
例えば、CopyKeyCond(Cancel, OK)とするとキャンセルキーに決定キーの判定条件が割り当てられます。<br>
キー配置をプレイヤーが自由に設定できるようなオプションの作成などに利用できるでしょう。<br>

<br><hr>

<div id = "icon"></div>
<h2>アイコンを設定しよう</h2>
ゲームのアイコンを設定してみましょう。<br>
<br><table border = "2"><tbody><tr><th>icon.ico</th></tr><tr><td>
<img src = "html_dat\icon.ico" width = "64"><br>
</td></tr></tbody></table><br>
何でもいいですが、とりあえずアイコン画像を用意します。ここでは<b>「icon.ico」</b>とします。<br>
このファイルは今までのようにvcxprojがあったディレクトリではなく、その一階層前の、slnファイルのある場所に置いてください。<br>
そして、同じディレクトリに<b>「Resource.rc」</b>という空のファイルを作成してください。<br>
これにてリソースファイルの定義を行います。Resource.rcをテキストエディタで開き、次のように書いてください。<br>
<br><table border = "2"><tbody><tr><td><b>
	101 ICON "icon.ico"<br>
</b></td></tr></tbody></table><br>
この場合は「icon.ico」なのでこう書いていますが、別のファイル名の場合は適宜変えてください。<br>
テンプレートではアイコン101番をウィンドウアイコンとして指定するようにしていますので、<br>
それにアイコンにしたい画像ファイルを関連付けることによってアイコンを設定できます。<br>
<br>
最後に、Visual Studioに戻ってソリューションエクスプローラーの「リソースファイル」に<br>
先ほどの「Resource.rc」のみ入れてください。これでビルドをすると、アイコンが置き換わるはずです。<br>

<br><hr>

<div id = "complete"></div>
<h2>ゲームの完成</h2>
晴れてゲームが完成しましたら、リリースビルドをして完成品にしましょう。<br>
ソリューション構成の「Debug」を「Release」に変更してビルドを行えば、リリースビルド完了です。<br>
素材の相対パスはできあがった実行ファイル（.exe）のあるディレクトリになるので、<br>
そこを相対パスとして素材を入れてください。<br>
<br>
素材はDXアーカイブ機能を用いることにより一つの「dxaファイル」にまとめることが可能です。<br>
便利な機能ですので、ぜひ別途ご参照ください。<br>
ただし、セーブデータなどはもちろんそれにはまとめられないのでご注意ください。<br>
<br>
<br>
このテンプレートは、DXライブラリをオブジェクト指向的に利用するためのものに過ぎず、<br>
また、２Ｄゲームを作成することしか想定されておりません。<br>
ご本家のDXライブラリには非常に多くの機能がありますので、<br>
より高度なことを行うためにはそちらをご参照になり、どんどん機能を拡張させていってください。<br>

<br><hr>

<div id = "sample"></div>
<h2>サンプルゲーム</h2>
今までご紹介しました機能を利用すれば、おおかたゲーム作れると思います。<br>
サンプルとしてゲームウォッチのヘルメットのリメイク作りましたので、参考にどうぞ。<br>
⇒ <a href = "http://yahoo.jp/box/g8ysdA" target = "_blank">ダウンロードサイトに飛びます</a><br>
<br>
単なるサンプルのはずが、色々詰め込んでしまって疲れたので、注釈あんまりありません。<br>
各クラスを閲覧する場合はヘッダファイルを見ておおよそ概要をつかんでいただき、<br>
必要なとこだけソースファイル見る、という形が良いと思います。<br>
内部システムフォルダの中身はテンプレートの初期状態からまったく変えていませんのでご安心ください。<br>
勢いで作ってしまったためにサンプルになってないんじゃないかというような作りですが、ご了承下さい。<br>
<br>
（同日：まさかのメモリリークバグがあったので、修正版をver1.01として公開しました）<br>

<br><hr>

2014年9月28日記 フェルミウム湾<br>
<br>

</body>
